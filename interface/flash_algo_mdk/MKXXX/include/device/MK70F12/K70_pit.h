/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_PIT_REGISTERS_H__
#define __HW_PIT_REGISTERS_H__

#include "regs.h"

/*
 * K70 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - HW_PIT_MCR - PIT Module Control Register
 * - HW_PIT_LDVAL0 - Timer Load Value Register
 * - HW_PIT_CVAL0 - Current Timer Value Register
 * - HW_PIT_TCTRL0 - Timer Control Register
 * - HW_PIT_TFLG0 - Timer Flag Register
 * - HW_PIT_LDVAL1 - Timer Load Value Register
 * - HW_PIT_CVAL1 - Current Timer Value Register
 * - HW_PIT_TCTRL1 - Timer Control Register
 * - HW_PIT_TFLG1 - Timer Flag Register
 * - HW_PIT_LDVAL2 - Timer Load Value Register
 * - HW_PIT_CVAL2 - Current Timer Value Register
 * - HW_PIT_TCTRL2 - Timer Control Register
 * - HW_PIT_TFLG2 - Timer Flag Register
 * - HW_PIT_LDVAL3 - Timer Load Value Register
 * - HW_PIT_CVAL3 - Current Timer Value Register
 * - HW_PIT_TCTRL3 - Timer Control Register
 * - HW_PIT_TFLG3 - Timer Flag Register
 *
 * - hw_pit_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_PIT_BASE
#define HW_PIT_INSTANCE_COUNT (1U) //!< Number of instances of the PIT module.
#define REGS_PIT_BASE (0x40037000U) //!< Base address for PIT.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_MCR - PIT Module Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000002U
 *
 * This register enables or disables the PIT timer clocks and controls the timers when the PIT
 * enters the Debug mode.
 */
typedef union _hw_pit_mcr
{
    uint32_t U;
    struct _hw_pit_mcr_bitfields
    {
        uint32_t FRZ : 1; //!< [0] Freeze
        uint32_t MDIS : 1; //!< [1] Module Disable - (PIT section)
        uint32_t RESERVED0 : 30; //!< [31:2] Reserved.
    } B;
} hw_pit_mcr_t;
#endif

/*!
 * @name Constants and macros for entire PIT_MCR register
 */
//@{
#define HW_PIT_MCR_ADDR      (REGS_PIT_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_MCR           (*(__IO hw_pit_mcr_t *) HW_PIT_MCR_ADDR)
#define HW_PIT_MCR_RD()      (HW_PIT_MCR.U)
#define HW_PIT_MCR_WR(v)     (HW_PIT_MCR.U = (v))
#define HW_PIT_MCR_SET(v)    (HW_PIT_MCR_WR(HW_PIT_MCR_RD() |  (v)))
#define HW_PIT_MCR_CLR(v)    (HW_PIT_MCR_WR(HW_PIT_MCR_RD() & ~(v)))
#define HW_PIT_MCR_TOG(v)    (HW_PIT_MCR_WR(HW_PIT_MCR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_MCR bitfields
 */

/*! @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0 - Timers continue to run in Debug mode.
 * - 1 - Timers are stopped in Debug mode.
 */
//@{
#define BP_PIT_MCR_FRZ      (0U)      //!< Bit position for PIT_MCR_FRZ.
#define BM_PIT_MCR_FRZ      (0x00000001U)  //!< Bit mask for PIT_MCR_FRZ.
#define BS_PIT_MCR_FRZ      (1U)  //!< Bitfield size in bits for PIT_MCR_FRZ.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_MCR_FRZ field.
#define BR_PIT_MCR_FRZ()   (BITBAND_ACCESS32(HW_PIT_MCR_ADDR, BP_PIT_MCR_FRZ))
#endif

//! @brief Format value for bitfield PIT_MCR_FRZ.
#define BF_PIT_MCR_FRZ(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_MCR_FRZ), uint32_t) & BM_PIT_MCR_FRZ)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FRZ field to a new value.
#define BW_PIT_MCR_FRZ(v)   (BITBAND_ACCESS32(HW_PIT_MCR_ADDR, BP_PIT_MCR_FRZ) = (v))
#endif
//@}

/*! @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other setup is done.
 *
 * Values:
 * - 0 - Clock for standard PIT timers is enabled.
 * - 1 - Clock for standard PIT timers is disabled.
 */
//@{
#define BP_PIT_MCR_MDIS      (1U)      //!< Bit position for PIT_MCR_MDIS.
#define BM_PIT_MCR_MDIS      (0x00000002U)  //!< Bit mask for PIT_MCR_MDIS.
#define BS_PIT_MCR_MDIS      (1U)  //!< Bitfield size in bits for PIT_MCR_MDIS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_MCR_MDIS field.
#define BR_PIT_MCR_MDIS()   (BITBAND_ACCESS32(HW_PIT_MCR_ADDR, BP_PIT_MCR_MDIS))
#endif

//! @brief Format value for bitfield PIT_MCR_MDIS.
#define BF_PIT_MCR_MDIS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_MCR_MDIS), uint32_t) & BM_PIT_MCR_MDIS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MDIS field to a new value.
#define BW_PIT_MCR_MDIS(v)   (BITBAND_ACCESS32(HW_PIT_MCR_ADDR, BP_PIT_MCR_MDIS) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_LDVAL0 - Timer Load Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_LDVAL0 - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
typedef union _hw_pit_ldval0
{
    uint32_t U;
    struct _hw_pit_ldval0_bitfields
    {
        uint32_t TSV : 32; //!< [31:0] Timer Start Value
    } B;
} hw_pit_ldval0_t;
#endif

/*!
 * @name Constants and macros for entire PIT_LDVAL0 register
 */
//@{
#define HW_PIT_LDVAL0_ADDR      (REGS_PIT_BASE + 0x100U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_LDVAL0           (*(__IO hw_pit_ldval0_t *) HW_PIT_LDVAL0_ADDR)
#define HW_PIT_LDVAL0_RD()      (HW_PIT_LDVAL0.U)
#define HW_PIT_LDVAL0_WR(v)     (HW_PIT_LDVAL0.U = (v))
#define HW_PIT_LDVAL0_SET(v)    (HW_PIT_LDVAL0_WR(HW_PIT_LDVAL0_RD() |  (v)))
#define HW_PIT_LDVAL0_CLR(v)    (HW_PIT_LDVAL0_WR(HW_PIT_LDVAL0_RD() & ~(v)))
#define HW_PIT_LDVAL0_TOG(v)    (HW_PIT_LDVAL0_WR(HW_PIT_LDVAL0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_LDVAL0 bitfields
 */

/*! @name Register PIT_LDVAL0, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0, then it will generate
 * an interrupt and load this register value again. Writing a new value to this register will not
 * restart the timer; instead the value will be loaded after the timer expires. To abort the current
 * cycle and start a timer period with the new value, the timer must be disabled and enabled again.
 */
//@{
#define BP_PIT_LDVAL0_TSV      (0U)      //!< Bit position for PIT_LDVAL0_TSV.
#define BM_PIT_LDVAL0_TSV      (0xffffffffU)  //!< Bit mask for PIT_LDVAL0_TSV.
#define BS_PIT_LDVAL0_TSV      (32U)  //!< Bitfield size in bits for PIT_LDVAL0_TSV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_LDVAL0_TSV field.
#define BR_PIT_LDVAL0_TSV()   (HW_PIT_LDVAL0.B.TSV)
#endif

//! @brief Format value for bitfield PIT_LDVAL0_TSV.
#define BF_PIT_LDVAL0_TSV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_LDVAL0_TSV), uint32_t) & BM_PIT_LDVAL0_TSV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSV field to a new value.
#define BW_PIT_LDVAL0_TSV(v)   (HW_PIT_LDVAL0_WR((HW_PIT_LDVAL0_RD() & ~BM_PIT_LDVAL0_TSV) | BF_PIT_LDVAL0_TSV(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_CVAL0 - Current Timer Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_CVAL0 - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
typedef union _hw_pit_cval0
{
    uint32_t U;
    struct _hw_pit_cval0_bitfields
    {
        uint32_t TVL : 32; //!< [31:0] Current Timer Value
    } B;
} hw_pit_cval0_t;
#endif

/*!
 * @name Constants and macros for entire PIT_CVAL0 register
 */
//@{
#define HW_PIT_CVAL0_ADDR      (REGS_PIT_BASE + 0x104U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_CVAL0           (*(__I hw_pit_cval0_t *) HW_PIT_CVAL0_ADDR)
#define HW_PIT_CVAL0_RD()      (HW_PIT_CVAL0.U)
#endif
//@}

/*
 * constants & macros for individual PIT_CVAL0 bitfields
 */

/*! @name Register PIT_CVAL0, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is disabled, do not use
 * this field as its value is unreliable. The timer uses a downcounter. The timer values are frozen
 * in Debug mode if MCR[FRZ] is set.
 */
//@{
#define BP_PIT_CVAL0_TVL      (0U)      //!< Bit position for PIT_CVAL0_TVL.
#define BM_PIT_CVAL0_TVL      (0xffffffffU)  //!< Bit mask for PIT_CVAL0_TVL.
#define BS_PIT_CVAL0_TVL      (32U)  //!< Bitfield size in bits for PIT_CVAL0_TVL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_CVAL0_TVL field.
#define BR_PIT_CVAL0_TVL()   (HW_PIT_CVAL0.B.TVL)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TCTRL0 - Timer Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TCTRL0 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These register contain the control bits for each timer.
 */
typedef union _hw_pit_tctrl0
{
    uint32_t U;
    struct _hw_pit_tctrl0_bitfields
    {
        uint32_t TEN : 1; //!< [0] Timer Enable
        uint32_t TIE : 1; //!< [1] Timer Interrupt Enable
        uint32_t CHN : 1; //!< [2] Chain Mode
        uint32_t RESERVED0 : 29; //!< [31:3] 
    } B;
} hw_pit_tctrl0_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TCTRL0 register
 */
//@{
#define HW_PIT_TCTRL0_ADDR      (REGS_PIT_BASE + 0x108U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TCTRL0           (*(__IO hw_pit_tctrl0_t *) HW_PIT_TCTRL0_ADDR)
#define HW_PIT_TCTRL0_RD()      (HW_PIT_TCTRL0.U)
#define HW_PIT_TCTRL0_WR(v)     (HW_PIT_TCTRL0.U = (v))
#define HW_PIT_TCTRL0_SET(v)    (HW_PIT_TCTRL0_WR(HW_PIT_TCTRL0_RD() |  (v)))
#define HW_PIT_TCTRL0_CLR(v)    (HW_PIT_TCTRL0_WR(HW_PIT_TCTRL0_RD() & ~(v)))
#define HW_PIT_TCTRL0_TOG(v)    (HW_PIT_TCTRL0_WR(HW_PIT_TCTRL0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TCTRL0 bitfields
 */

/*! @name Register PIT_TCTRL0, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
//@{
#define BP_PIT_TCTRL0_TEN      (0U)      //!< Bit position for PIT_TCTRL0_TEN.
#define BM_PIT_TCTRL0_TEN      (0x00000001U)  //!< Bit mask for PIT_TCTRL0_TEN.
#define BS_PIT_TCTRL0_TEN      (1U)  //!< Bitfield size in bits for PIT_TCTRL0_TEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL0_TEN field.
#define BR_PIT_TCTRL0_TEN()   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_TEN))
#endif

//! @brief Format value for bitfield PIT_TCTRL0_TEN.
#define BF_PIT_TCTRL0_TEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL0_TEN), uint32_t) & BM_PIT_TCTRL0_TEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TEN field to a new value.
#define BW_PIT_TCTRL0_TEN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_TEN) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL0, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt will immediately
 * cause an interrupt event. To avoid this, the associated TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
//@{
#define BP_PIT_TCTRL0_TIE      (1U)      //!< Bit position for PIT_TCTRL0_TIE.
#define BM_PIT_TCTRL0_TIE      (0x00000002U)  //!< Bit mask for PIT_TCTRL0_TIE.
#define BS_PIT_TCTRL0_TIE      (1U)  //!< Bitfield size in bits for PIT_TCTRL0_TIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL0_TIE field.
#define BR_PIT_TCTRL0_TIE()   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_TIE))
#endif

//! @brief Format value for bitfield PIT_TCTRL0_TIE.
#define BF_PIT_TCTRL0_TIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL0_TIE), uint32_t) & BM_PIT_TCTRL0_TIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE field to a new value.
#define BW_PIT_TCTRL0_TIE(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_TIE) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL0, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1. Timer 0 can not be
 * changed.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is
 *     chained to Timer 1.
 */
//@{
#define BP_PIT_TCTRL0_CHN      (2U)      //!< Bit position for PIT_TCTRL0_CHN.
#define BM_PIT_TCTRL0_CHN      (0x00000004U)  //!< Bit mask for PIT_TCTRL0_CHN.
#define BS_PIT_TCTRL0_CHN      (1U)  //!< Bitfield size in bits for PIT_TCTRL0_CHN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL0_CHN field.
#define BR_PIT_TCTRL0_CHN()   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_CHN))
#endif

//! @brief Format value for bitfield PIT_TCTRL0_CHN.
#define BF_PIT_TCTRL0_CHN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL0_CHN), uint32_t) & BM_PIT_TCTRL0_CHN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHN field to a new value.
#define BW_PIT_TCTRL0_CHN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL0_ADDR, BP_PIT_TCTRL0_CHN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TFLG0 - Timer Flag Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TFLG0 - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
typedef union _hw_pit_tflg0
{
    uint32_t U;
    struct _hw_pit_tflg0_bitfields
    {
        uint32_t TIF : 1; //!< [0] Timer Interrupt Flag
        uint32_t RESERVED0 : 31; //!< [31:1] 
    } B;
} hw_pit_tflg0_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TFLG0 register
 */
//@{
#define HW_PIT_TFLG0_ADDR      (REGS_PIT_BASE + 0x10cU)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TFLG0           (*(__IO hw_pit_tflg0_t *) HW_PIT_TFLG0_ADDR)
#define HW_PIT_TFLG0_RD()      (HW_PIT_TFLG0.U)
#define HW_PIT_TFLG0_WR(v)     (HW_PIT_TFLG0.U = (v))
#define HW_PIT_TFLG0_SET(v)    (HW_PIT_TFLG0_WR(HW_PIT_TFLG0_RD() |  (v)))
#define HW_PIT_TFLG0_CLR(v)    (HW_PIT_TFLG0_WR(HW_PIT_TFLG0_RD() & ~(v)))
#define HW_PIT_TFLG0_TOG(v)    (HW_PIT_TFLG0_WR(HW_PIT_TFLG0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TFLG0 bitfields
 */

/*! @name Register PIT_TFLG0, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it. Writing 0 has no
 * effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
//@{
#define BP_PIT_TFLG0_TIF      (0U)      //!< Bit position for PIT_TFLG0_TIF.
#define BM_PIT_TFLG0_TIF      (0x00000001U)  //!< Bit mask for PIT_TFLG0_TIF.
#define BS_PIT_TFLG0_TIF      (1U)  //!< Bitfield size in bits for PIT_TFLG0_TIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TFLG0_TIF field.
#define BR_PIT_TFLG0_TIF()   (BITBAND_ACCESS32(HW_PIT_TFLG0_ADDR, BP_PIT_TFLG0_TIF))
#endif

//! @brief Format value for bitfield PIT_TFLG0_TIF.
#define BF_PIT_TFLG0_TIF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TFLG0_TIF), uint32_t) & BM_PIT_TFLG0_TIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIF field to a new value.
#define BW_PIT_TFLG0_TIF(v)   (BITBAND_ACCESS32(HW_PIT_TFLG0_ADDR, BP_PIT_TFLG0_TIF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_LDVAL1 - Timer Load Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_LDVAL1 - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
typedef union _hw_pit_ldval1
{
    uint32_t U;
    struct _hw_pit_ldval1_bitfields
    {
        uint32_t TSV : 32; //!< [31:0] Timer Start Value
    } B;
} hw_pit_ldval1_t;
#endif

/*!
 * @name Constants and macros for entire PIT_LDVAL1 register
 */
//@{
#define HW_PIT_LDVAL1_ADDR      (REGS_PIT_BASE + 0x110U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_LDVAL1           (*(__IO hw_pit_ldval1_t *) HW_PIT_LDVAL1_ADDR)
#define HW_PIT_LDVAL1_RD()      (HW_PIT_LDVAL1.U)
#define HW_PIT_LDVAL1_WR(v)     (HW_PIT_LDVAL1.U = (v))
#define HW_PIT_LDVAL1_SET(v)    (HW_PIT_LDVAL1_WR(HW_PIT_LDVAL1_RD() |  (v)))
#define HW_PIT_LDVAL1_CLR(v)    (HW_PIT_LDVAL1_WR(HW_PIT_LDVAL1_RD() & ~(v)))
#define HW_PIT_LDVAL1_TOG(v)    (HW_PIT_LDVAL1_WR(HW_PIT_LDVAL1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_LDVAL1 bitfields
 */

/*! @name Register PIT_LDVAL1, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0, then it will generate
 * an interrupt and load this register value again. Writing a new value to this register will not
 * restart the timer; instead the value will be loaded after the timer expires. To abort the current
 * cycle and start a timer period with the new value, the timer must be disabled and enabled again.
 */
//@{
#define BP_PIT_LDVAL1_TSV      (0U)      //!< Bit position for PIT_LDVAL1_TSV.
#define BM_PIT_LDVAL1_TSV      (0xffffffffU)  //!< Bit mask for PIT_LDVAL1_TSV.
#define BS_PIT_LDVAL1_TSV      (32U)  //!< Bitfield size in bits for PIT_LDVAL1_TSV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_LDVAL1_TSV field.
#define BR_PIT_LDVAL1_TSV()   (HW_PIT_LDVAL1.B.TSV)
#endif

//! @brief Format value for bitfield PIT_LDVAL1_TSV.
#define BF_PIT_LDVAL1_TSV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_LDVAL1_TSV), uint32_t) & BM_PIT_LDVAL1_TSV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSV field to a new value.
#define BW_PIT_LDVAL1_TSV(v)   (HW_PIT_LDVAL1_WR((HW_PIT_LDVAL1_RD() & ~BM_PIT_LDVAL1_TSV) | BF_PIT_LDVAL1_TSV(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_CVAL1 - Current Timer Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_CVAL1 - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
typedef union _hw_pit_cval1
{
    uint32_t U;
    struct _hw_pit_cval1_bitfields
    {
        uint32_t TVL : 32; //!< [31:0] Current Timer Value
    } B;
} hw_pit_cval1_t;
#endif

/*!
 * @name Constants and macros for entire PIT_CVAL1 register
 */
//@{
#define HW_PIT_CVAL1_ADDR      (REGS_PIT_BASE + 0x114U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_CVAL1           (*(__I hw_pit_cval1_t *) HW_PIT_CVAL1_ADDR)
#define HW_PIT_CVAL1_RD()      (HW_PIT_CVAL1.U)
#endif
//@}

/*
 * constants & macros for individual PIT_CVAL1 bitfields
 */

/*! @name Register PIT_CVAL1, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is disabled, do not use
 * this field as its value is unreliable. The timer uses a downcounter. The timer values are frozen
 * in Debug mode if MCR[FRZ] is set.
 */
//@{
#define BP_PIT_CVAL1_TVL      (0U)      //!< Bit position for PIT_CVAL1_TVL.
#define BM_PIT_CVAL1_TVL      (0xffffffffU)  //!< Bit mask for PIT_CVAL1_TVL.
#define BS_PIT_CVAL1_TVL      (32U)  //!< Bitfield size in bits for PIT_CVAL1_TVL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_CVAL1_TVL field.
#define BR_PIT_CVAL1_TVL()   (HW_PIT_CVAL1.B.TVL)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TCTRL1 - Timer Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TCTRL1 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These register contain the control bits for each timer.
 */
typedef union _hw_pit_tctrl1
{
    uint32_t U;
    struct _hw_pit_tctrl1_bitfields
    {
        uint32_t TEN : 1; //!< [0] Timer Enable
        uint32_t TIE : 1; //!< [1] Timer Interrupt Enable
        uint32_t CHN : 1; //!< [2] Chain Mode
        uint32_t RESERVED0 : 29; //!< [31:3] 
    } B;
} hw_pit_tctrl1_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TCTRL1 register
 */
//@{
#define HW_PIT_TCTRL1_ADDR      (REGS_PIT_BASE + 0x118U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TCTRL1           (*(__IO hw_pit_tctrl1_t *) HW_PIT_TCTRL1_ADDR)
#define HW_PIT_TCTRL1_RD()      (HW_PIT_TCTRL1.U)
#define HW_PIT_TCTRL1_WR(v)     (HW_PIT_TCTRL1.U = (v))
#define HW_PIT_TCTRL1_SET(v)    (HW_PIT_TCTRL1_WR(HW_PIT_TCTRL1_RD() |  (v)))
#define HW_PIT_TCTRL1_CLR(v)    (HW_PIT_TCTRL1_WR(HW_PIT_TCTRL1_RD() & ~(v)))
#define HW_PIT_TCTRL1_TOG(v)    (HW_PIT_TCTRL1_WR(HW_PIT_TCTRL1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TCTRL1 bitfields
 */

/*! @name Register PIT_TCTRL1, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
//@{
#define BP_PIT_TCTRL1_TEN      (0U)      //!< Bit position for PIT_TCTRL1_TEN.
#define BM_PIT_TCTRL1_TEN      (0x00000001U)  //!< Bit mask for PIT_TCTRL1_TEN.
#define BS_PIT_TCTRL1_TEN      (1U)  //!< Bitfield size in bits for PIT_TCTRL1_TEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL1_TEN field.
#define BR_PIT_TCTRL1_TEN()   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_TEN))
#endif

//! @brief Format value for bitfield PIT_TCTRL1_TEN.
#define BF_PIT_TCTRL1_TEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL1_TEN), uint32_t) & BM_PIT_TCTRL1_TEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TEN field to a new value.
#define BW_PIT_TCTRL1_TEN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_TEN) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL1, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt will immediately
 * cause an interrupt event. To avoid this, the associated TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
//@{
#define BP_PIT_TCTRL1_TIE      (1U)      //!< Bit position for PIT_TCTRL1_TIE.
#define BM_PIT_TCTRL1_TIE      (0x00000002U)  //!< Bit mask for PIT_TCTRL1_TIE.
#define BS_PIT_TCTRL1_TIE      (1U)  //!< Bitfield size in bits for PIT_TCTRL1_TIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL1_TIE field.
#define BR_PIT_TCTRL1_TIE()   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_TIE))
#endif

//! @brief Format value for bitfield PIT_TCTRL1_TIE.
#define BF_PIT_TCTRL1_TIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL1_TIE), uint32_t) & BM_PIT_TCTRL1_TIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE field to a new value.
#define BW_PIT_TCTRL1_TIE(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_TIE) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL1, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1. Timer 0 can not be
 * changed.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is
 *     chained to Timer 1.
 */
//@{
#define BP_PIT_TCTRL1_CHN      (2U)      //!< Bit position for PIT_TCTRL1_CHN.
#define BM_PIT_TCTRL1_CHN      (0x00000004U)  //!< Bit mask for PIT_TCTRL1_CHN.
#define BS_PIT_TCTRL1_CHN      (1U)  //!< Bitfield size in bits for PIT_TCTRL1_CHN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL1_CHN field.
#define BR_PIT_TCTRL1_CHN()   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_CHN))
#endif

//! @brief Format value for bitfield PIT_TCTRL1_CHN.
#define BF_PIT_TCTRL1_CHN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL1_CHN), uint32_t) & BM_PIT_TCTRL1_CHN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHN field to a new value.
#define BW_PIT_TCTRL1_CHN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL1_ADDR, BP_PIT_TCTRL1_CHN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TFLG1 - Timer Flag Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TFLG1 - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
typedef union _hw_pit_tflg1
{
    uint32_t U;
    struct _hw_pit_tflg1_bitfields
    {
        uint32_t TIF : 1; //!< [0] Timer Interrupt Flag
        uint32_t RESERVED0 : 31; //!< [31:1] 
    } B;
} hw_pit_tflg1_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TFLG1 register
 */
//@{
#define HW_PIT_TFLG1_ADDR      (REGS_PIT_BASE + 0x11cU)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TFLG1           (*(__IO hw_pit_tflg1_t *) HW_PIT_TFLG1_ADDR)
#define HW_PIT_TFLG1_RD()      (HW_PIT_TFLG1.U)
#define HW_PIT_TFLG1_WR(v)     (HW_PIT_TFLG1.U = (v))
#define HW_PIT_TFLG1_SET(v)    (HW_PIT_TFLG1_WR(HW_PIT_TFLG1_RD() |  (v)))
#define HW_PIT_TFLG1_CLR(v)    (HW_PIT_TFLG1_WR(HW_PIT_TFLG1_RD() & ~(v)))
#define HW_PIT_TFLG1_TOG(v)    (HW_PIT_TFLG1_WR(HW_PIT_TFLG1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TFLG1 bitfields
 */

/*! @name Register PIT_TFLG1, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it. Writing 0 has no
 * effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
//@{
#define BP_PIT_TFLG1_TIF      (0U)      //!< Bit position for PIT_TFLG1_TIF.
#define BM_PIT_TFLG1_TIF      (0x00000001U)  //!< Bit mask for PIT_TFLG1_TIF.
#define BS_PIT_TFLG1_TIF      (1U)  //!< Bitfield size in bits for PIT_TFLG1_TIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TFLG1_TIF field.
#define BR_PIT_TFLG1_TIF()   (BITBAND_ACCESS32(HW_PIT_TFLG1_ADDR, BP_PIT_TFLG1_TIF))
#endif

//! @brief Format value for bitfield PIT_TFLG1_TIF.
#define BF_PIT_TFLG1_TIF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TFLG1_TIF), uint32_t) & BM_PIT_TFLG1_TIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIF field to a new value.
#define BW_PIT_TFLG1_TIF(v)   (BITBAND_ACCESS32(HW_PIT_TFLG1_ADDR, BP_PIT_TFLG1_TIF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_LDVAL2 - Timer Load Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_LDVAL2 - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
typedef union _hw_pit_ldval2
{
    uint32_t U;
    struct _hw_pit_ldval2_bitfields
    {
        uint32_t TSV : 32; //!< [31:0] Timer Start Value
    } B;
} hw_pit_ldval2_t;
#endif

/*!
 * @name Constants and macros for entire PIT_LDVAL2 register
 */
//@{
#define HW_PIT_LDVAL2_ADDR      (REGS_PIT_BASE + 0x120U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_LDVAL2           (*(__IO hw_pit_ldval2_t *) HW_PIT_LDVAL2_ADDR)
#define HW_PIT_LDVAL2_RD()      (HW_PIT_LDVAL2.U)
#define HW_PIT_LDVAL2_WR(v)     (HW_PIT_LDVAL2.U = (v))
#define HW_PIT_LDVAL2_SET(v)    (HW_PIT_LDVAL2_WR(HW_PIT_LDVAL2_RD() |  (v)))
#define HW_PIT_LDVAL2_CLR(v)    (HW_PIT_LDVAL2_WR(HW_PIT_LDVAL2_RD() & ~(v)))
#define HW_PIT_LDVAL2_TOG(v)    (HW_PIT_LDVAL2_WR(HW_PIT_LDVAL2_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_LDVAL2 bitfields
 */

/*! @name Register PIT_LDVAL2, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0, then it will generate
 * an interrupt and load this register value again. Writing a new value to this register will not
 * restart the timer; instead the value will be loaded after the timer expires. To abort the current
 * cycle and start a timer period with the new value, the timer must be disabled and enabled again.
 */
//@{
#define BP_PIT_LDVAL2_TSV      (0U)      //!< Bit position for PIT_LDVAL2_TSV.
#define BM_PIT_LDVAL2_TSV      (0xffffffffU)  //!< Bit mask for PIT_LDVAL2_TSV.
#define BS_PIT_LDVAL2_TSV      (32U)  //!< Bitfield size in bits for PIT_LDVAL2_TSV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_LDVAL2_TSV field.
#define BR_PIT_LDVAL2_TSV()   (HW_PIT_LDVAL2.B.TSV)
#endif

//! @brief Format value for bitfield PIT_LDVAL2_TSV.
#define BF_PIT_LDVAL2_TSV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_LDVAL2_TSV), uint32_t) & BM_PIT_LDVAL2_TSV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSV field to a new value.
#define BW_PIT_LDVAL2_TSV(v)   (HW_PIT_LDVAL2_WR((HW_PIT_LDVAL2_RD() & ~BM_PIT_LDVAL2_TSV) | BF_PIT_LDVAL2_TSV(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_CVAL2 - Current Timer Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_CVAL2 - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
typedef union _hw_pit_cval2
{
    uint32_t U;
    struct _hw_pit_cval2_bitfields
    {
        uint32_t TVL : 32; //!< [31:0] Current Timer Value
    } B;
} hw_pit_cval2_t;
#endif

/*!
 * @name Constants and macros for entire PIT_CVAL2 register
 */
//@{
#define HW_PIT_CVAL2_ADDR      (REGS_PIT_BASE + 0x124U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_CVAL2           (*(__I hw_pit_cval2_t *) HW_PIT_CVAL2_ADDR)
#define HW_PIT_CVAL2_RD()      (HW_PIT_CVAL2.U)
#endif
//@}

/*
 * constants & macros for individual PIT_CVAL2 bitfields
 */

/*! @name Register PIT_CVAL2, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is disabled, do not use
 * this field as its value is unreliable. The timer uses a downcounter. The timer values are frozen
 * in Debug mode if MCR[FRZ] is set.
 */
//@{
#define BP_PIT_CVAL2_TVL      (0U)      //!< Bit position for PIT_CVAL2_TVL.
#define BM_PIT_CVAL2_TVL      (0xffffffffU)  //!< Bit mask for PIT_CVAL2_TVL.
#define BS_PIT_CVAL2_TVL      (32U)  //!< Bitfield size in bits for PIT_CVAL2_TVL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_CVAL2_TVL field.
#define BR_PIT_CVAL2_TVL()   (HW_PIT_CVAL2.B.TVL)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TCTRL2 - Timer Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TCTRL2 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These register contain the control bits for each timer.
 */
typedef union _hw_pit_tctrl2
{
    uint32_t U;
    struct _hw_pit_tctrl2_bitfields
    {
        uint32_t TEN : 1; //!< [0] Timer Enable
        uint32_t TIE : 1; //!< [1] Timer Interrupt Enable
        uint32_t CHN : 1; //!< [2] Chain Mode
        uint32_t RESERVED0 : 29; //!< [31:3] 
    } B;
} hw_pit_tctrl2_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TCTRL2 register
 */
//@{
#define HW_PIT_TCTRL2_ADDR      (REGS_PIT_BASE + 0x128U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TCTRL2           (*(__IO hw_pit_tctrl2_t *) HW_PIT_TCTRL2_ADDR)
#define HW_PIT_TCTRL2_RD()      (HW_PIT_TCTRL2.U)
#define HW_PIT_TCTRL2_WR(v)     (HW_PIT_TCTRL2.U = (v))
#define HW_PIT_TCTRL2_SET(v)    (HW_PIT_TCTRL2_WR(HW_PIT_TCTRL2_RD() |  (v)))
#define HW_PIT_TCTRL2_CLR(v)    (HW_PIT_TCTRL2_WR(HW_PIT_TCTRL2_RD() & ~(v)))
#define HW_PIT_TCTRL2_TOG(v)    (HW_PIT_TCTRL2_WR(HW_PIT_TCTRL2_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TCTRL2 bitfields
 */

/*! @name Register PIT_TCTRL2, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
//@{
#define BP_PIT_TCTRL2_TEN      (0U)      //!< Bit position for PIT_TCTRL2_TEN.
#define BM_PIT_TCTRL2_TEN      (0x00000001U)  //!< Bit mask for PIT_TCTRL2_TEN.
#define BS_PIT_TCTRL2_TEN      (1U)  //!< Bitfield size in bits for PIT_TCTRL2_TEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL2_TEN field.
#define BR_PIT_TCTRL2_TEN()   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_TEN))
#endif

//! @brief Format value for bitfield PIT_TCTRL2_TEN.
#define BF_PIT_TCTRL2_TEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL2_TEN), uint32_t) & BM_PIT_TCTRL2_TEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TEN field to a new value.
#define BW_PIT_TCTRL2_TEN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_TEN) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL2, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt will immediately
 * cause an interrupt event. To avoid this, the associated TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
//@{
#define BP_PIT_TCTRL2_TIE      (1U)      //!< Bit position for PIT_TCTRL2_TIE.
#define BM_PIT_TCTRL2_TIE      (0x00000002U)  //!< Bit mask for PIT_TCTRL2_TIE.
#define BS_PIT_TCTRL2_TIE      (1U)  //!< Bitfield size in bits for PIT_TCTRL2_TIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL2_TIE field.
#define BR_PIT_TCTRL2_TIE()   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_TIE))
#endif

//! @brief Format value for bitfield PIT_TCTRL2_TIE.
#define BF_PIT_TCTRL2_TIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL2_TIE), uint32_t) & BM_PIT_TCTRL2_TIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE field to a new value.
#define BW_PIT_TCTRL2_TIE(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_TIE) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL2, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1. Timer 0 can not be
 * changed.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is
 *     chained to Timer 1.
 */
//@{
#define BP_PIT_TCTRL2_CHN      (2U)      //!< Bit position for PIT_TCTRL2_CHN.
#define BM_PIT_TCTRL2_CHN      (0x00000004U)  //!< Bit mask for PIT_TCTRL2_CHN.
#define BS_PIT_TCTRL2_CHN      (1U)  //!< Bitfield size in bits for PIT_TCTRL2_CHN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL2_CHN field.
#define BR_PIT_TCTRL2_CHN()   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_CHN))
#endif

//! @brief Format value for bitfield PIT_TCTRL2_CHN.
#define BF_PIT_TCTRL2_CHN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL2_CHN), uint32_t) & BM_PIT_TCTRL2_CHN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHN field to a new value.
#define BW_PIT_TCTRL2_CHN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL2_ADDR, BP_PIT_TCTRL2_CHN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TFLG2 - Timer Flag Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TFLG2 - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
typedef union _hw_pit_tflg2
{
    uint32_t U;
    struct _hw_pit_tflg2_bitfields
    {
        uint32_t TIF : 1; //!< [0] Timer Interrupt Flag
        uint32_t RESERVED0 : 31; //!< [31:1] 
    } B;
} hw_pit_tflg2_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TFLG2 register
 */
//@{
#define HW_PIT_TFLG2_ADDR      (REGS_PIT_BASE + 0x12cU)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TFLG2           (*(__IO hw_pit_tflg2_t *) HW_PIT_TFLG2_ADDR)
#define HW_PIT_TFLG2_RD()      (HW_PIT_TFLG2.U)
#define HW_PIT_TFLG2_WR(v)     (HW_PIT_TFLG2.U = (v))
#define HW_PIT_TFLG2_SET(v)    (HW_PIT_TFLG2_WR(HW_PIT_TFLG2_RD() |  (v)))
#define HW_PIT_TFLG2_CLR(v)    (HW_PIT_TFLG2_WR(HW_PIT_TFLG2_RD() & ~(v)))
#define HW_PIT_TFLG2_TOG(v)    (HW_PIT_TFLG2_WR(HW_PIT_TFLG2_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TFLG2 bitfields
 */

/*! @name Register PIT_TFLG2, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it. Writing 0 has no
 * effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
//@{
#define BP_PIT_TFLG2_TIF      (0U)      //!< Bit position for PIT_TFLG2_TIF.
#define BM_PIT_TFLG2_TIF      (0x00000001U)  //!< Bit mask for PIT_TFLG2_TIF.
#define BS_PIT_TFLG2_TIF      (1U)  //!< Bitfield size in bits for PIT_TFLG2_TIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TFLG2_TIF field.
#define BR_PIT_TFLG2_TIF()   (BITBAND_ACCESS32(HW_PIT_TFLG2_ADDR, BP_PIT_TFLG2_TIF))
#endif

//! @brief Format value for bitfield PIT_TFLG2_TIF.
#define BF_PIT_TFLG2_TIF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TFLG2_TIF), uint32_t) & BM_PIT_TFLG2_TIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIF field to a new value.
#define BW_PIT_TFLG2_TIF(v)   (BITBAND_ACCESS32(HW_PIT_TFLG2_ADDR, BP_PIT_TFLG2_TIF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_LDVAL3 - Timer Load Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_LDVAL3 - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
typedef union _hw_pit_ldval3
{
    uint32_t U;
    struct _hw_pit_ldval3_bitfields
    {
        uint32_t TSV : 32; //!< [31:0] Timer Start Value
    } B;
} hw_pit_ldval3_t;
#endif

/*!
 * @name Constants and macros for entire PIT_LDVAL3 register
 */
//@{
#define HW_PIT_LDVAL3_ADDR      (REGS_PIT_BASE + 0x130U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_LDVAL3           (*(__IO hw_pit_ldval3_t *) HW_PIT_LDVAL3_ADDR)
#define HW_PIT_LDVAL3_RD()      (HW_PIT_LDVAL3.U)
#define HW_PIT_LDVAL3_WR(v)     (HW_PIT_LDVAL3.U = (v))
#define HW_PIT_LDVAL3_SET(v)    (HW_PIT_LDVAL3_WR(HW_PIT_LDVAL3_RD() |  (v)))
#define HW_PIT_LDVAL3_CLR(v)    (HW_PIT_LDVAL3_WR(HW_PIT_LDVAL3_RD() & ~(v)))
#define HW_PIT_LDVAL3_TOG(v)    (HW_PIT_LDVAL3_WR(HW_PIT_LDVAL3_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_LDVAL3 bitfields
 */

/*! @name Register PIT_LDVAL3, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0, then it will generate
 * an interrupt and load this register value again. Writing a new value to this register will not
 * restart the timer; instead the value will be loaded after the timer expires. To abort the current
 * cycle and start a timer period with the new value, the timer must be disabled and enabled again.
 */
//@{
#define BP_PIT_LDVAL3_TSV      (0U)      //!< Bit position for PIT_LDVAL3_TSV.
#define BM_PIT_LDVAL3_TSV      (0xffffffffU)  //!< Bit mask for PIT_LDVAL3_TSV.
#define BS_PIT_LDVAL3_TSV      (32U)  //!< Bitfield size in bits for PIT_LDVAL3_TSV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_LDVAL3_TSV field.
#define BR_PIT_LDVAL3_TSV()   (HW_PIT_LDVAL3.B.TSV)
#endif

//! @brief Format value for bitfield PIT_LDVAL3_TSV.
#define BF_PIT_LDVAL3_TSV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_LDVAL3_TSV), uint32_t) & BM_PIT_LDVAL3_TSV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TSV field to a new value.
#define BW_PIT_LDVAL3_TSV(v)   (HW_PIT_LDVAL3_WR((HW_PIT_LDVAL3_RD() & ~BM_PIT_LDVAL3_TSV) | BF_PIT_LDVAL3_TSV(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_CVAL3 - Current Timer Value Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_CVAL3 - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
typedef union _hw_pit_cval3
{
    uint32_t U;
    struct _hw_pit_cval3_bitfields
    {
        uint32_t TVL : 32; //!< [31:0] Current Timer Value
    } B;
} hw_pit_cval3_t;
#endif

/*!
 * @name Constants and macros for entire PIT_CVAL3 register
 */
//@{
#define HW_PIT_CVAL3_ADDR      (REGS_PIT_BASE + 0x134U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_CVAL3           (*(__I hw_pit_cval3_t *) HW_PIT_CVAL3_ADDR)
#define HW_PIT_CVAL3_RD()      (HW_PIT_CVAL3.U)
#endif
//@}

/*
 * constants & macros for individual PIT_CVAL3 bitfields
 */

/*! @name Register PIT_CVAL3, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is disabled, do not use
 * this field as its value is unreliable. The timer uses a downcounter. The timer values are frozen
 * in Debug mode if MCR[FRZ] is set.
 */
//@{
#define BP_PIT_CVAL3_TVL      (0U)      //!< Bit position for PIT_CVAL3_TVL.
#define BM_PIT_CVAL3_TVL      (0xffffffffU)  //!< Bit mask for PIT_CVAL3_TVL.
#define BS_PIT_CVAL3_TVL      (32U)  //!< Bitfield size in bits for PIT_CVAL3_TVL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_CVAL3_TVL field.
#define BR_PIT_CVAL3_TVL()   (HW_PIT_CVAL3.B.TVL)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TCTRL3 - Timer Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TCTRL3 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These register contain the control bits for each timer.
 */
typedef union _hw_pit_tctrl3
{
    uint32_t U;
    struct _hw_pit_tctrl3_bitfields
    {
        uint32_t TEN : 1; //!< [0] Timer Enable
        uint32_t TIE : 1; //!< [1] Timer Interrupt Enable
        uint32_t CHN : 1; //!< [2] Chain Mode
        uint32_t RESERVED0 : 29; //!< [31:3] 
    } B;
} hw_pit_tctrl3_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TCTRL3 register
 */
//@{
#define HW_PIT_TCTRL3_ADDR      (REGS_PIT_BASE + 0x138U)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TCTRL3           (*(__IO hw_pit_tctrl3_t *) HW_PIT_TCTRL3_ADDR)
#define HW_PIT_TCTRL3_RD()      (HW_PIT_TCTRL3.U)
#define HW_PIT_TCTRL3_WR(v)     (HW_PIT_TCTRL3.U = (v))
#define HW_PIT_TCTRL3_SET(v)    (HW_PIT_TCTRL3_WR(HW_PIT_TCTRL3_RD() |  (v)))
#define HW_PIT_TCTRL3_CLR(v)    (HW_PIT_TCTRL3_WR(HW_PIT_TCTRL3_RD() & ~(v)))
#define HW_PIT_TCTRL3_TOG(v)    (HW_PIT_TCTRL3_WR(HW_PIT_TCTRL3_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TCTRL3 bitfields
 */

/*! @name Register PIT_TCTRL3, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
//@{
#define BP_PIT_TCTRL3_TEN      (0U)      //!< Bit position for PIT_TCTRL3_TEN.
#define BM_PIT_TCTRL3_TEN      (0x00000001U)  //!< Bit mask for PIT_TCTRL3_TEN.
#define BS_PIT_TCTRL3_TEN      (1U)  //!< Bitfield size in bits for PIT_TCTRL3_TEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL3_TEN field.
#define BR_PIT_TCTRL3_TEN()   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_TEN))
#endif

//! @brief Format value for bitfield PIT_TCTRL3_TEN.
#define BF_PIT_TCTRL3_TEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL3_TEN), uint32_t) & BM_PIT_TCTRL3_TEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TEN field to a new value.
#define BW_PIT_TCTRL3_TEN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_TEN) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL3, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt will immediately
 * cause an interrupt event. To avoid this, the associated TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
//@{
#define BP_PIT_TCTRL3_TIE      (1U)      //!< Bit position for PIT_TCTRL3_TIE.
#define BM_PIT_TCTRL3_TIE      (0x00000002U)  //!< Bit mask for PIT_TCTRL3_TIE.
#define BS_PIT_TCTRL3_TIE      (1U)  //!< Bitfield size in bits for PIT_TCTRL3_TIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL3_TIE field.
#define BR_PIT_TCTRL3_TIE()   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_TIE))
#endif

//! @brief Format value for bitfield PIT_TCTRL3_TIE.
#define BF_PIT_TCTRL3_TIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL3_TIE), uint32_t) & BM_PIT_TCTRL3_TIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIE field to a new value.
#define BW_PIT_TCTRL3_TIE(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_TIE) = (v))
#endif
//@}

/*! @name Register PIT_TCTRL3, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1. Timer 0 can not be
 * changed.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is
 *     chained to Timer 1.
 */
//@{
#define BP_PIT_TCTRL3_CHN      (2U)      //!< Bit position for PIT_TCTRL3_CHN.
#define BM_PIT_TCTRL3_CHN      (0x00000004U)  //!< Bit mask for PIT_TCTRL3_CHN.
#define BS_PIT_TCTRL3_CHN      (1U)  //!< Bitfield size in bits for PIT_TCTRL3_CHN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TCTRL3_CHN field.
#define BR_PIT_TCTRL3_CHN()   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_CHN))
#endif

//! @brief Format value for bitfield PIT_TCTRL3_CHN.
#define BF_PIT_TCTRL3_CHN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TCTRL3_CHN), uint32_t) & BM_PIT_TCTRL3_CHN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CHN field to a new value.
#define BW_PIT_TCTRL3_CHN(v)   (BITBAND_ACCESS32(HW_PIT_TCTRL3_ADDR, BP_PIT_TCTRL3_CHN) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PIT_TFLG3 - Timer Flag Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PIT_TFLG3 - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
typedef union _hw_pit_tflg3
{
    uint32_t U;
    struct _hw_pit_tflg3_bitfields
    {
        uint32_t TIF : 1; //!< [0] Timer Interrupt Flag
        uint32_t RESERVED0 : 31; //!< [31:1] 
    } B;
} hw_pit_tflg3_t;
#endif

/*!
 * @name Constants and macros for entire PIT_TFLG3 register
 */
//@{
#define HW_PIT_TFLG3_ADDR      (REGS_PIT_BASE + 0x13cU)

#ifndef __LANGUAGE_ASM__
#define HW_PIT_TFLG3           (*(__IO hw_pit_tflg3_t *) HW_PIT_TFLG3_ADDR)
#define HW_PIT_TFLG3_RD()      (HW_PIT_TFLG3.U)
#define HW_PIT_TFLG3_WR(v)     (HW_PIT_TFLG3.U = (v))
#define HW_PIT_TFLG3_SET(v)    (HW_PIT_TFLG3_WR(HW_PIT_TFLG3_RD() |  (v)))
#define HW_PIT_TFLG3_CLR(v)    (HW_PIT_TFLG3_WR(HW_PIT_TFLG3_RD() & ~(v)))
#define HW_PIT_TFLG3_TOG(v)    (HW_PIT_TFLG3_WR(HW_PIT_TFLG3_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PIT_TFLG3 bitfields
 */

/*! @name Register PIT_TFLG3, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it. Writing 0 has no
 * effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
//@{
#define BP_PIT_TFLG3_TIF      (0U)      //!< Bit position for PIT_TFLG3_TIF.
#define BM_PIT_TFLG3_TIF      (0x00000001U)  //!< Bit mask for PIT_TFLG3_TIF.
#define BS_PIT_TFLG3_TIF      (1U)  //!< Bitfield size in bits for PIT_TFLG3_TIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PIT_TFLG3_TIF field.
#define BR_PIT_TFLG3_TIF()   (BITBAND_ACCESS32(HW_PIT_TFLG3_ADDR, BP_PIT_TFLG3_TIF))
#endif

//! @brief Format value for bitfield PIT_TFLG3_TIF.
#define BF_PIT_TFLG3_TIF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PIT_TFLG3_TIF), uint32_t) & BM_PIT_TFLG3_TIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TIF field to a new value.
#define BW_PIT_TFLG3_TIF(v)   (BITBAND_ACCESS32(HW_PIT_TFLG3_ADDR, BP_PIT_TFLG3_TIF) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_pit_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All PIT module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_pit
{
    __IO hw_pit_mcr_t MCR; //!< [0x0] PIT Module Control Register
    uint32_t _reserved0[63];
    __IO hw_pit_ldval0_t LDVAL0; //!< [0x100] Timer Load Value Register
    __I hw_pit_cval0_t CVAL0; //!< [0x104] Current Timer Value Register
    __IO hw_pit_tctrl0_t TCTRL0; //!< [0x108] Timer Control Register
    __IO hw_pit_tflg0_t TFLG0; //!< [0x10c] Timer Flag Register
    __IO hw_pit_ldval1_t LDVAL1; //!< [0x110] Timer Load Value Register
    __I hw_pit_cval1_t CVAL1; //!< [0x114] Current Timer Value Register
    __IO hw_pit_tctrl1_t TCTRL1; //!< [0x118] Timer Control Register
    __IO hw_pit_tflg1_t TFLG1; //!< [0x11c] Timer Flag Register
    __IO hw_pit_ldval2_t LDVAL2; //!< [0x120] Timer Load Value Register
    __I hw_pit_cval2_t CVAL2; //!< [0x124] Current Timer Value Register
    __IO hw_pit_tctrl2_t TCTRL2; //!< [0x128] Timer Control Register
    __IO hw_pit_tflg2_t TFLG2; //!< [0x12c] Timer Flag Register
    __IO hw_pit_ldval3_t LDVAL3; //!< [0x130] Timer Load Value Register
    __I hw_pit_cval3_t CVAL3; //!< [0x134] Current Timer Value Register
    __IO hw_pit_tctrl3_t TCTRL3; //!< [0x138] Timer Control Register
    __IO hw_pit_tflg3_t TFLG3; //!< [0x13c] Timer Flag Register
} hw_pit_t;
#pragma pack()

//! @brief Macro to access all PIT registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_PIT</code>.
#define HW_PIT     (*(hw_pit_t *) REGS_PIT_BASE)
#endif

#endif // __HW_PIT_REGISTERS_H__
// v22/130417/1.2.6
// EOF
