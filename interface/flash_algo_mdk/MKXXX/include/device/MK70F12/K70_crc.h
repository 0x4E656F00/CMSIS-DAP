/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_CRC_REGISTERS_H__
#define __HW_CRC_REGISTERS_H__

#include "regs.h"

/*
 * K70 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - HW_CRC_DATA - CRC Data register
 * - HW_CRC_GPOLY - CRC Polynomial register
 * - HW_CRC_CTRL - CRC Control register
 *
 * - hw_crc_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_CRC_BASE
#define HW_CRC_INSTANCE_COUNT (1U) //!< Number of instances of the CRC module.
#define REGS_CRC_BASE (0x40032000U) //!< Base address for CRC.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CRC_DATA - CRC Data register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xffffffffU
 *
 * The CRC Data register contains the value of the seed, data, and checksum. When CTRL[WAS] is set,
 * any write to the data register is regarded as the seed value. When CTRL[WAS] is cleared, any
 * write to the data register is regarded as data for general CRC computation. In 16-bit CRC mode,
 * the HU and HL fields are not used for programming the seed value, and reads of these fields
 * return an indeterminate value. In 32-bit CRC mode, all fields are used for programming the seed
 * value. When programming data values, the values can be written 8 bits, 16 bits, or 32 bits at a
 * time, provided all bytes are contiguous; with MSB of data value written first. After all data
 * values are written, the CRC result can be read from this data register. In 16-bit CRC mode, the
 * CRC result is available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value, provided the CRC
 * module is configured.
 */
typedef union _hw_crc_data
{
    uint32_t U;
    struct _hw_crc_data_bitfields
    {
        uint32_t LL : 8; //!< [7:0] CRC Low Lower Byte
        uint32_t LU : 8; //!< [15:8] CRC Low Upper Byte
        uint32_t HL : 8; //!< [23:16] CRC High Lower Byte
        uint32_t HU : 8; //!< [31:24] CRC High Upper Byte
    } B;
} hw_crc_data_t;
#endif

/*!
 * @name Constants and macros for entire CRC_DATA register
 */
//@{
#define HW_CRC_DATA_ADDR      (REGS_CRC_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_CRC_DATA           (*(__IO hw_crc_data_t *) HW_CRC_DATA_ADDR)
#define HW_CRC_DATA_RD()      (HW_CRC_DATA.U)
#define HW_CRC_DATA_WR(v)     (HW_CRC_DATA.U = (v))
#define HW_CRC_DATA_SET(v)    (HW_CRC_DATA_WR(HW_CRC_DATA_RD() |  (v)))
#define HW_CRC_DATA_CLR(v)    (HW_CRC_DATA_WR(HW_CRC_DATA_RD() & ~(v)))
#define HW_CRC_DATA_TOG(v)    (HW_CRC_DATA_WR(HW_CRC_DATA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CRC_DATA bitfields
 */

/*! @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value. When CTRL[WAS] is
 * 0, data written to this field is used for CRC checksum generation.
 */
//@{
#define BP_CRC_DATA_LL      (0U)      //!< Bit position for CRC_DATA_LL.
#define BM_CRC_DATA_LL      (0x000000ffU)  //!< Bit mask for CRC_DATA_LL.
#define BS_CRC_DATA_LL      (8U)  //!< Bitfield size in bits for CRC_DATA_LL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_DATA_LL field.
#define BR_CRC_DATA_LL()   (HW_CRC_DATA.B.LL)
#endif

//! @brief Format value for bitfield CRC_DATA_LL.
#define BF_CRC_DATA_LL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_DATA_LL), uint32_t) & BM_CRC_DATA_LL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LL field to a new value.
#define BW_CRC_DATA_LL(v)   (HW_CRC_DATA_WR((HW_CRC_DATA_RD() & ~BM_CRC_DATA_LL) | BF_CRC_DATA_LL(v)))
#endif
//@}

/*! @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value. When CTRL[WAS] is
 * 0, data written to this field is used for CRC checksum generation.
 */
//@{
#define BP_CRC_DATA_LU      (8U)      //!< Bit position for CRC_DATA_LU.
#define BM_CRC_DATA_LU      (0x0000ff00U)  //!< Bit mask for CRC_DATA_LU.
#define BS_CRC_DATA_LU      (8U)  //!< Bitfield size in bits for CRC_DATA_LU.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_DATA_LU field.
#define BR_CRC_DATA_LU()   (HW_CRC_DATA.B.LU)
#endif

//! @brief Format value for bitfield CRC_DATA_LU.
#define BF_CRC_DATA_LU(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_DATA_LU), uint32_t) & BM_CRC_DATA_LU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LU field to a new value.
#define BW_CRC_DATA_LU(v)   (HW_CRC_DATA_WR((HW_CRC_DATA_RD() & ~BM_CRC_DATA_LU) | BF_CRC_DATA_LU(v)))
#endif
//@}

/*! @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming a seed value. In
 * 32-bit CRC mode (CTRL[TCRC] is 1), values written to this field are part of the seed value when
 * CTRL[WAS] is 1. When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation in both 16-bit and 32-bit CRC modes.
 */
//@{
#define BP_CRC_DATA_HL      (16U)      //!< Bit position for CRC_DATA_HL.
#define BM_CRC_DATA_HL      (0x00ff0000U)  //!< Bit mask for CRC_DATA_HL.
#define BS_CRC_DATA_HL      (8U)  //!< Bitfield size in bits for CRC_DATA_HL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_DATA_HL field.
#define BR_CRC_DATA_HL()   (HW_CRC_DATA.B.HL)
#endif

//! @brief Format value for bitfield CRC_DATA_HL.
#define BF_CRC_DATA_HL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_DATA_HL), uint32_t) & BM_CRC_DATA_HL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HL field to a new value.
#define BW_CRC_DATA_HL(v)   (HW_CRC_DATA_WR((HW_CRC_DATA_RD() & ~BM_CRC_DATA_HL) | BF_CRC_DATA_HL(v)))
#endif
//@}

/*! @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming a seed value. In
 * 32-bit CRC mode (CTRL[TCRC] is 1), values written to this field are part of the seed value when
 * CTRL[WAS] is 1. When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation in both 16-bit and 32-bit CRC modes.
 */
//@{
#define BP_CRC_DATA_HU      (24U)      //!< Bit position for CRC_DATA_HU.
#define BM_CRC_DATA_HU      (0xff000000U)  //!< Bit mask for CRC_DATA_HU.
#define BS_CRC_DATA_HU      (8U)  //!< Bitfield size in bits for CRC_DATA_HU.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_DATA_HU field.
#define BR_CRC_DATA_HU()   (HW_CRC_DATA.B.HU)
#endif

//! @brief Format value for bitfield CRC_DATA_HU.
#define BF_CRC_DATA_HU(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_DATA_HU), uint32_t) & BM_CRC_DATA_HU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HU field to a new value.
#define BW_CRC_DATA_HU(v)   (HW_CRC_DATA_WR((HW_CRC_DATA_RD() & ~BM_CRC_DATA_HU) | BF_CRC_DATA_HU(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CRC_GPOLY - CRC Polynomial register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation. The HIGH field
 * contains the upper 16 bits of the CRC polynomial, which are used only in 32-bit CRC mode. Writes
 * to the HIGH field are ignored in 16-bit CRC mode. The LOW field contains the lower 16 bits of the
 * CRC polynomial, which are used in both 16- and 32-bit CRC modes.
 */
typedef union _hw_crc_gpoly
{
    uint32_t U;
    struct _hw_crc_gpoly_bitfields
    {
        uint32_t LOW : 16; //!< [15:0] Low Polynominal Half-word
        uint32_t HIGH : 16; //!< [31:16] High Polynominal Half-word
    } B;
} hw_crc_gpoly_t;
#endif

/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
//@{
#define HW_CRC_GPOLY_ADDR      (REGS_CRC_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_CRC_GPOLY           (*(__IO hw_crc_gpoly_t *) HW_CRC_GPOLY_ADDR)
#define HW_CRC_GPOLY_RD()      (HW_CRC_GPOLY.U)
#define HW_CRC_GPOLY_WR(v)     (HW_CRC_GPOLY.U = (v))
#define HW_CRC_GPOLY_SET(v)    (HW_CRC_GPOLY_WR(HW_CRC_GPOLY_RD() |  (v)))
#define HW_CRC_GPOLY_CLR(v)    (HW_CRC_GPOLY_WR(HW_CRC_GPOLY_RD() & ~(v)))
#define HW_CRC_GPOLY_TOG(v)    (HW_CRC_GPOLY_WR(HW_CRC_GPOLY_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CRC_GPOLY bitfields
 */

/*! @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
//@{
#define BP_CRC_GPOLY_LOW      (0U)      //!< Bit position for CRC_GPOLY_LOW.
#define BM_CRC_GPOLY_LOW      (0x0000ffffU)  //!< Bit mask for CRC_GPOLY_LOW.
#define BS_CRC_GPOLY_LOW      (16U)  //!< Bitfield size in bits for CRC_GPOLY_LOW.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_GPOLY_LOW field.
#define BR_CRC_GPOLY_LOW()   (HW_CRC_GPOLY.B.LOW)
#endif

//! @brief Format value for bitfield CRC_GPOLY_LOW.
#define BF_CRC_GPOLY_LOW(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_GPOLY_LOW), uint32_t) & BM_CRC_GPOLY_LOW)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOW field to a new value.
#define BW_CRC_GPOLY_LOW(v)   (HW_CRC_GPOLY_WR((HW_CRC_GPOLY_RD() & ~BM_CRC_GPOLY_LOW) | BF_CRC_GPOLY_LOW(v)))
#endif
//@}

/*! @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not writable in 16-bit
 * CRC mode (CTRL[TCRC] is 0).
 */
//@{
#define BP_CRC_GPOLY_HIGH      (16U)      //!< Bit position for CRC_GPOLY_HIGH.
#define BM_CRC_GPOLY_HIGH      (0xffff0000U)  //!< Bit mask for CRC_GPOLY_HIGH.
#define BS_CRC_GPOLY_HIGH      (16U)  //!< Bitfield size in bits for CRC_GPOLY_HIGH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_GPOLY_HIGH field.
#define BR_CRC_GPOLY_HIGH()   (HW_CRC_GPOLY.B.HIGH)
#endif

//! @brief Format value for bitfield CRC_GPOLY_HIGH.
#define BF_CRC_GPOLY_HIGH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_GPOLY_HIGH), uint32_t) & BM_CRC_GPOLY_HIGH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HIGH field to a new value.
#define BW_CRC_GPOLY_HIGH(v)   (HW_CRC_GPOLY_WR((HW_CRC_GPOLY_RD() & ~BM_CRC_GPOLY_HIGH) | BF_CRC_GPOLY_HIGH(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CRC_CTRL - CRC Control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module. Appropriate bits must be
 * set before starting a new CRC calculation. A new CRC calculation is initialized by asserting
 * CTRL[WAS] and then writing the seed into the CRC data register.
 */
typedef union _hw_crc_ctrl
{
    uint32_t U;
    struct _hw_crc_ctrl_bitfields
    {
        uint32_t RESERVED0 : 24; //!< [23:0] 
        uint32_t TCRC : 1; //!< [24] Width of CRC protocol.
        uint32_t WAS : 1; //!< [25] Write CRC Data Register As Seed
        uint32_t FXOR : 1; //!< [26] Complement Read Of CRC Data Register
        uint32_t RESERVED1 : 5; //!< [31:27] Reserved.
    } B;
} hw_crc_ctrl_t;
#endif

/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
//@{
#define HW_CRC_CTRL_ADDR      (REGS_CRC_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_CRC_CTRL           (*(__IO hw_crc_ctrl_t *) HW_CRC_CTRL_ADDR)
#define HW_CRC_CTRL_RD()      (HW_CRC_CTRL.U)
#define HW_CRC_CTRL_WR(v)     (HW_CRC_CTRL.U = (v))
#define HW_CRC_CTRL_SET(v)    (HW_CRC_CTRL_WR(HW_CRC_CTRL_RD() |  (v)))
#define HW_CRC_CTRL_CLR(v)    (HW_CRC_CTRL_WR(HW_CRC_CTRL_RD() & ~(v)))
#define HW_CRC_CTRL_TOG(v)    (HW_CRC_CTRL_WR(HW_CRC_CTRL_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CRC_CTRL bitfields
 */

/*! @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
//@{
#define BP_CRC_CTRL_TCRC      (24U)      //!< Bit position for CRC_CTRL_TCRC.
#define BM_CRC_CTRL_TCRC      (0x01000000U)  //!< Bit mask for CRC_CTRL_TCRC.
#define BS_CRC_CTRL_TCRC      (1U)  //!< Bitfield size in bits for CRC_CTRL_TCRC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_CTRL_TCRC field.
#define BR_CRC_CTRL_TCRC()   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_TCRC))
#endif

//! @brief Format value for bitfield CRC_CTRL_TCRC.
#define BF_CRC_CTRL_TCRC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_CTRL_TCRC), uint32_t) & BM_CRC_CTRL_TCRC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TCRC field to a new value.
#define BW_CRC_CTRL_TCRC(v)   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_TCRC) = (v))
#endif
//@}

/*! @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed value. When
 * deasserted, a value written to the CRC data register is taken as data for CRC computation.
 *
 * Values:
 * - 0 - Writes to the CRC data register are data values.
 * - 1 - Writes to the CRC data register are seed values.
 */
//@{
#define BP_CRC_CTRL_WAS      (25U)      //!< Bit position for CRC_CTRL_WAS.
#define BM_CRC_CTRL_WAS      (0x02000000U)  //!< Bit mask for CRC_CTRL_WAS.
#define BS_CRC_CTRL_WAS      (1U)  //!< Bitfield size in bits for CRC_CTRL_WAS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_CTRL_WAS field.
#define BR_CRC_CTRL_WAS()   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_WAS))
#endif

//! @brief Format value for bitfield CRC_CTRL_WAS.
#define BF_CRC_CTRL_WAS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_CTRL_WAS), uint32_t) & BM_CRC_CTRL_WAS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the WAS field to a new value.
#define BW_CRC_CTRL_WAS(v)   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_WAS) = (v))
#endif
//@}

/*! @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or 0xFFFF. Asserting
 * this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of the CRC Data register.
 */
//@{
#define BP_CRC_CTRL_FXOR      (26U)      //!< Bit position for CRC_CTRL_FXOR.
#define BM_CRC_CTRL_FXOR      (0x04000000U)  //!< Bit mask for CRC_CTRL_FXOR.
#define BS_CRC_CTRL_FXOR      (1U)  //!< Bitfield size in bits for CRC_CTRL_FXOR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CRC_CTRL_FXOR field.
#define BR_CRC_CTRL_FXOR()   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_FXOR))
#endif

//! @brief Format value for bitfield CRC_CTRL_FXOR.
#define BF_CRC_CTRL_FXOR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CRC_CTRL_FXOR), uint32_t) & BM_CRC_CTRL_FXOR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FXOR field to a new value.
#define BW_CRC_CTRL_FXOR(v)   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR, BP_CRC_CTRL_FXOR) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_crc_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All CRC module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_crc
{
    __IO hw_crc_data_t DATA; //!< [0x0] CRC Data register
    __IO hw_crc_gpoly_t GPOLY; //!< [0x4] CRC Polynomial register
    __IO hw_crc_ctrl_t CTRL; //!< [0x8] CRC Control register
} hw_crc_t;
#pragma pack()

//! @brief Macro to access all CRC registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_CRC</code>.
#define HW_CRC     (*(hw_crc_t *) REGS_CRC_BASE)
#endif

#endif // __HW_CRC_REGISTERS_H__
// v22/130417/1.2.6
// EOF
