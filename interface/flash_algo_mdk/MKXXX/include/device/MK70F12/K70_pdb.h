/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_PDB_REGISTERS_H__
#define __HW_PDB_REGISTERS_H__

#include "regs.h"

/*
 * K70 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - HW_PDB_SC - Status and Control register
 * - HW_PDB_MOD - Modulus register
 * - HW_PDB_CNT - Counter register
 * - HW_PDB_IDLY - Interrupt Delay register
 * - HW_PDB_CH0C1 - Channel n Control register 1
 * - HW_PDB_CH0S - Channel n Status register
 * - HW_PDB_CH0DLY0 - Channel n Delay 0 register
 * - HW_PDB_CH0DLY1 - Channel n Delay 1 register
 * - HW_PDB_CH1C1 - Channel n Control register 1
 * - HW_PDB_CH1S - Channel n Status register
 * - HW_PDB_CH1DLY0 - Channel n Delay 0 register
 * - HW_PDB_CH1DLY1 - Channel n Delay 1 register
 * - HW_PDB_CH2C1 - Channel n Control register 1
 * - HW_PDB_CH2S - Channel n Status register
 * - HW_PDB_CH2DLY0 - Channel n Delay 0 register
 * - HW_PDB_CH2DLY1 - Channel n Delay 1 register
 * - HW_PDB_CH3C1 - Channel n Control register 1
 * - HW_PDB_CH3S - Channel n Status register
 * - HW_PDB_CH3DLY0 - Channel n Delay 0 register
 * - HW_PDB_CH3DLY1 - Channel n Delay 1 register
 * - HW_PDB_DACINTC0 - DAC Interval Trigger n Control register
 * - HW_PDB_DACINT0 - DAC Interval n register
 * - HW_PDB_DACINTC1 - DAC Interval Trigger n Control register
 * - HW_PDB_DACINT1 - DAC Interval n register
 * - HW_PDB_POEN - Pulse-Out n Enable register
 * - HW_PDB_POnDLY - Pulse-Out n Delay register
 *
 * - hw_pdb_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_PDB_BASE
#define HW_PDB_INSTANCE_COUNT (1U) //!< Number of instances of the PDB module.
#define REGS_PDB_BASE (0x40036000U) //!< Base address for PDB.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_SC - Status and Control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_sc
{
    uint32_t U;
    struct _hw_pdb_sc_bitfields
    {
        uint32_t LDOK : 1; //!< [0] Load OK
        uint32_t CONT : 1; //!< [1] Continuous Mode Enable
        uint32_t MULT : 2; //!< [3:2] Multiplication Factor Select for Prescaler
        uint32_t RESERVED0 : 1; //!< [4] 
        uint32_t PDBIE : 1; //!< [5] PDB Interrupt Enable
        uint32_t PDBIF : 1; //!< [6] PDB Interrupt Flag
        uint32_t PDBEN : 1; //!< [7] PDB Enable
        uint32_t TRGSEL : 4; //!< [11:8] Trigger Input Source Select
        uint32_t PRESCALER : 3; //!< [14:12] Prescaler Divider Select
        uint32_t DMAEN : 1; //!< [15] DMA Enable
        uint32_t SWTRIG : 1; //!< [16] Software Trigger
        uint32_t PDBEIE : 1; //!< [17] PDB Sequence Error Interrupt Enable
        uint32_t LDMOD : 2; //!< [19:18] Load Mode Select
        uint32_t RESERVED1 : 12; //!< [31:20] 
    } B;
} hw_pdb_sc_t;
#endif

/*!
 * @name Constants and macros for entire PDB_SC register
 */
//@{
#define HW_PDB_SC_ADDR      (REGS_PDB_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_SC           (*(__IO hw_pdb_sc_t *) HW_PDB_SC_ADDR)
#define HW_PDB_SC_RD()      (HW_PDB_SC.U)
#define HW_PDB_SC_WR(v)     (HW_PDB_SC.U = (v))
#define HW_PDB_SC_SET(v)    (HW_PDB_SC_WR(HW_PDB_SC_RD() |  (v)))
#define HW_PDB_SC_CLR(v)    (HW_PDB_SC_WR(HW_PDB_SC_RD() & ~(v)))
#define HW_PDB_SC_TOG(v)    (HW_PDB_SC_WR(HW_PDB_SC_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_SC bitfields
 */

/*! @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm, DACINTx, and POyDLY
 * with the values written to their buffers. The MOD, IDLY, CHnDLYm, DACINTx, and POyDLY will take
 * effect according to the LDMOD. After 1 is written to the LDOK field, the values in the buffers of
 * above registers are not effective and the buffers cannot be written until the values in buffers
 * are loaded into their internal registers. LDOK can be written only when PDBEN is set or it can be
 * written at the same time with PDBEN being written to 1. It is automatically cleared when the
 * values in buffers are loaded into the internal registers or the PDBEN is cleared. Writing 0 to it
 * has no effect.
 */
//@{
#define BP_PDB_SC_LDOK      (0U)      //!< Bit position for PDB_SC_LDOK.
#define BM_PDB_SC_LDOK      (0x00000001U)  //!< Bit mask for PDB_SC_LDOK.
#define BS_PDB_SC_LDOK      (1U)  //!< Bitfield size in bits for PDB_SC_LDOK.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_LDOK field.
#define BR_PDB_SC_LDOK()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_LDOK))
#endif

//! @brief Format value for bitfield PDB_SC_LDOK.
#define BF_PDB_SC_LDOK(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_LDOK), uint32_t) & BM_PDB_SC_LDOK)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LDOK field to a new value.
#define BW_PDB_SC_LDOK(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_LDOK) = (v))
#endif
//@}

/*! @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0 - PDB operation in One-Shot mode
 * - 1 - PDB operation in Continuous mode
 */
//@{
#define BP_PDB_SC_CONT      (1U)      //!< Bit position for PDB_SC_CONT.
#define BM_PDB_SC_CONT      (0x00000002U)  //!< Bit mask for PDB_SC_CONT.
#define BS_PDB_SC_CONT      (1U)  //!< Bitfield size in bits for PDB_SC_CONT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_CONT field.
#define BR_PDB_SC_CONT()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_CONT))
#endif

//! @brief Format value for bitfield PDB_SC_CONT.
#define BF_PDB_SC_CONT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_CONT), uint32_t) & BM_PDB_SC_CONT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CONT field to a new value.
#define BW_PDB_SC_CONT(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_CONT) = (v))
#endif
//@}

/*! @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter clock.
 *
 * Values:
 * - 00 - Multiplication factor is 1.
 * - 01 - Multiplication factor is 10.
 * - 10 - Multiplication factor is 20.
 * - 11 - Multiplication factor is 40.
 */
//@{
#define BP_PDB_SC_MULT      (2U)      //!< Bit position for PDB_SC_MULT.
#define BM_PDB_SC_MULT      (0x0000000cU)  //!< Bit mask for PDB_SC_MULT.
#define BS_PDB_SC_MULT      (2U)  //!< Bitfield size in bits for PDB_SC_MULT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_MULT field.
#define BR_PDB_SC_MULT()   (HW_PDB_SC.B.MULT)
#endif

//! @brief Format value for bitfield PDB_SC_MULT.
#define BF_PDB_SC_MULT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_MULT), uint32_t) & BM_PDB_SC_MULT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MULT field to a new value.
#define BW_PDB_SC_MULT(v)   (HW_PDB_SC_WR((HW_PDB_SC_RD() & ~BM_PDB_SC_MULT) | BF_PDB_SC_MULT(v)))
#endif
//@}

/*! @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF generates a PDB
 * interrupt.
 *
 * Values:
 * - 0 - PDB interrupt disabled.
 * - 1 - PDB interrupt enabled.
 */
//@{
#define BP_PDB_SC_PDBIE      (5U)      //!< Bit position for PDB_SC_PDBIE.
#define BM_PDB_SC_PDBIE      (0x00000020U)  //!< Bit mask for PDB_SC_PDBIE.
#define BS_PDB_SC_PDBIE      (1U)  //!< Bitfield size in bits for PDB_SC_PDBIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_PDBIE field.
#define BR_PDB_SC_PDBIE()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBIE))
#endif

//! @brief Format value for bitfield PDB_SC_PDBIE.
#define BF_PDB_SC_PDBIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_PDBIE), uint32_t) & BM_PDB_SC_PDBIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PDBIE field to a new value.
#define BW_PDB_SC_PDBIE(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBIE) = (v))
#endif
//@}

/*! @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register. Writing zero clears this
 * field.
 */
//@{
#define BP_PDB_SC_PDBIF      (6U)      //!< Bit position for PDB_SC_PDBIF.
#define BM_PDB_SC_PDBIF      (0x00000040U)  //!< Bit mask for PDB_SC_PDBIF.
#define BS_PDB_SC_PDBIF      (1U)  //!< Bitfield size in bits for PDB_SC_PDBIF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_PDBIF field.
#define BR_PDB_SC_PDBIF()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBIF))
#endif

//! @brief Format value for bitfield PDB_SC_PDBIF.
#define BF_PDB_SC_PDBIF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_PDBIF), uint32_t) & BM_PDB_SC_PDBIF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PDBIF field to a new value.
#define BW_PDB_SC_PDBIF(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBIF) = (v))
#endif
//@}

/*! @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0 - PDB disabled. Counter is off.
 * - 1 - PDB enabled.
 */
//@{
#define BP_PDB_SC_PDBEN      (7U)      //!< Bit position for PDB_SC_PDBEN.
#define BM_PDB_SC_PDBEN      (0x00000080U)  //!< Bit mask for PDB_SC_PDBEN.
#define BS_PDB_SC_PDBEN      (1U)  //!< Bitfield size in bits for PDB_SC_PDBEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_PDBEN field.
#define BR_PDB_SC_PDBEN()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBEN))
#endif

//! @brief Format value for bitfield PDB_SC_PDBEN.
#define BF_PDB_SC_PDBEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_PDBEN), uint32_t) & BM_PDB_SC_PDBEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PDBEN field to a new value.
#define BW_PDB_SC_PDBEN(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBEN) = (v))
#endif
//@}

/*! @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be internal or
 * external (EXTRG pin), or the software trigger. Please refer to Chip Configuration chapter for the
 * actual PDB input trigger connections.
 *
 * Values:
 * - 0000 - Trigger-In 0 is selected.
 * - 0001 - Trigger-In 1 is selected.
 * - 0010 - Trigger-In 2 is selected.
 * - 0011 - Trigger-In 3 is selected.
 * - 0100 - Trigger-In 4 is selected.
 * - 0101 - Trigger-In 5 is selected.
 * - 0110 - Trigger-In 6 is selected.
 * - 0111 - Trigger-In 7 is selected.
 * - 1000 - Trigger-In 8 is selected.
 * - 1001 - Trigger-In 9 is selected.
 * - 1010 - Trigger-In 10 is selected.
 * - 1011 - Trigger-In 11 is selected.
 * - 1100 - Trigger-In 12 is selected.
 * - 1101 - Trigger-In 13 is selected.
 * - 1110 - Trigger-In 14 is selected.
 * - 1111 - Software trigger is selected.
 */
//@{
#define BP_PDB_SC_TRGSEL      (8U)      //!< Bit position for PDB_SC_TRGSEL.
#define BM_PDB_SC_TRGSEL      (0x00000f00U)  //!< Bit mask for PDB_SC_TRGSEL.
#define BS_PDB_SC_TRGSEL      (4U)  //!< Bitfield size in bits for PDB_SC_TRGSEL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_TRGSEL field.
#define BR_PDB_SC_TRGSEL()   (HW_PDB_SC.B.TRGSEL)
#endif

//! @brief Format value for bitfield PDB_SC_TRGSEL.
#define BF_PDB_SC_TRGSEL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_TRGSEL), uint32_t) & BM_PDB_SC_TRGSEL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TRGSEL field to a new value.
#define BW_PDB_SC_TRGSEL(v)   (HW_PDB_SC_WR((HW_PDB_SC_RD() & ~BM_PDB_SC_TRGSEL) | BF_PDB_SC_TRGSEL(v)))
#endif
//@}

/*! @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 000 - Counting uses the peripheral clock divided by multiplication factor selected by MULT.
 * - 001 - Counting uses the peripheral clock divided by twice of the multiplication factor selected by MULT.
 * - 010 - Counting uses the peripheral clock divided by four times of the multiplication factor selected by
 *     MULT.
 * - 011 - Counting uses the peripheral clock divided by eight times of the multiplication factor selected by
 *     MULT.
 * - 100 - Counting uses the peripheral clock divided by 16 times of the multiplication factor selected by
 *     MULT.
 * - 101 - Counting uses the peripheral clock divided by 32 times of the multiplication factor selected by
 *     MULT.
 * - 110 - Counting uses the peripheral clock divided by 64 times of the multiplication factor selected by
 *     MULT.
 * - 111 - Counting uses the peripheral clock divided by 128 times of the multiplication factor selected by
 *     MULT.
 */
//@{
#define BP_PDB_SC_PRESCALER      (12U)      //!< Bit position for PDB_SC_PRESCALER.
#define BM_PDB_SC_PRESCALER      (0x00007000U)  //!< Bit mask for PDB_SC_PRESCALER.
#define BS_PDB_SC_PRESCALER      (3U)  //!< Bitfield size in bits for PDB_SC_PRESCALER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_PRESCALER field.
#define BR_PDB_SC_PRESCALER()   (HW_PDB_SC.B.PRESCALER)
#endif

//! @brief Format value for bitfield PDB_SC_PRESCALER.
#define BF_PDB_SC_PRESCALER(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_PRESCALER), uint32_t) & BM_PDB_SC_PRESCALER)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PRESCALER field to a new value.
#define BW_PDB_SC_PRESCALER(v)   (HW_PDB_SC_WR((HW_PDB_SC_RD() & ~BM_PDB_SC_PRESCALER) | BF_PDB_SC_PRESCALER(v)))
#endif
//@}

/*! @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an interrupt.
 *
 * Values:
 * - 0 - DMA disabled.
 * - 1 - DMA enabled.
 */
//@{
#define BP_PDB_SC_DMAEN      (15U)      //!< Bit position for PDB_SC_DMAEN.
#define BM_PDB_SC_DMAEN      (0x00008000U)  //!< Bit mask for PDB_SC_DMAEN.
#define BS_PDB_SC_DMAEN      (1U)  //!< Bitfield size in bits for PDB_SC_DMAEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_DMAEN field.
#define BR_PDB_SC_DMAEN()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_DMAEN))
#endif

//! @brief Format value for bitfield PDB_SC_DMAEN.
#define BF_PDB_SC_DMAEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_DMAEN), uint32_t) & BM_PDB_SC_DMAEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMAEN field to a new value.
#define BW_PDB_SC_DMAEN(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_DMAEN) = (v))
#endif
//@}

/*! @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input source, writing 1
 * to this field resets and restarts the counter. Writing 0 to this field has no effect. Reading
 * this field results 0.
 */
//@{
#define BP_PDB_SC_SWTRIG      (16U)      //!< Bit position for PDB_SC_SWTRIG.
#define BM_PDB_SC_SWTRIG      (0x00010000U)  //!< Bit mask for PDB_SC_SWTRIG.
#define BS_PDB_SC_SWTRIG      (1U)  //!< Bitfield size in bits for PDB_SC_SWTRIG.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_SWTRIG field.
#define BR_PDB_SC_SWTRIG()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_SWTRIG))
#endif

//! @brief Format value for bitfield PDB_SC_SWTRIG.
#define BF_PDB_SC_SWTRIG(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_SWTRIG), uint32_t) & BM_PDB_SC_SWTRIG)
//@}

/*! @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the PDB channel sequence
 * error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0 - PDB sequence error interrupt disabled.
 * - 1 - PDB sequence error interrupt enabled.
 */
//@{
#define BP_PDB_SC_PDBEIE      (17U)      //!< Bit position for PDB_SC_PDBEIE.
#define BM_PDB_SC_PDBEIE      (0x00020000U)  //!< Bit mask for PDB_SC_PDBEIE.
#define BS_PDB_SC_PDBEIE      (1U)  //!< Bitfield size in bits for PDB_SC_PDBEIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_PDBEIE field.
#define BR_PDB_SC_PDBEIE()   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBEIE))
#endif

//! @brief Format value for bitfield PDB_SC_PDBEIE.
#define BF_PDB_SC_PDBEIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_PDBEIE), uint32_t) & BM_PDB_SC_PDBEIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PDBEIE field to a new value.
#define BW_PDB_SC_PDBEIE(v)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR, BP_PDB_SC_PDBEIE) = (v))
#endif
//@}

/*! @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CH n DLY m , INT x , and PO y DLY registers, after 1 is
 * written to LDOK.
 *
 * Values:
 * - 00 - The internal registers are loaded with the values from their buffers immediately after 1 is written
 *     to LDOK.
 * - 01 - The internal registers are loaded with the values from their buffers when the PDB counter reaches
 *     the MOD register value after 1 is written to LDOK.
 * - 10 - The internal registers are loaded with the values from their buffers when a trigger input event is
 *     detected after 1 is written to LDOK.
 * - 11 - The internal registers are loaded with the values from their buffers when either the PDB counter
 *     reaches the MOD register value or a trigger input event is detected, after 1 is written to
 *     LDOK.
 */
//@{
#define BP_PDB_SC_LDMOD      (18U)      //!< Bit position for PDB_SC_LDMOD.
#define BM_PDB_SC_LDMOD      (0x000c0000U)  //!< Bit mask for PDB_SC_LDMOD.
#define BS_PDB_SC_LDMOD      (2U)  //!< Bitfield size in bits for PDB_SC_LDMOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_SC_LDMOD field.
#define BR_PDB_SC_LDMOD()   (HW_PDB_SC.B.LDMOD)
#endif

//! @brief Format value for bitfield PDB_SC_LDMOD.
#define BF_PDB_SC_LDMOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_SC_LDMOD), uint32_t) & BM_PDB_SC_LDMOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LDMOD field to a new value.
#define BW_PDB_SC_LDMOD(v)   (HW_PDB_SC_WR((HW_PDB_SC_RD() & ~BM_PDB_SC_LDMOD) | BF_PDB_SC_LDMOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_MOD - Modulus register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000ffffU
 */
typedef union _hw_pdb_mod
{
    uint32_t U;
    struct _hw_pdb_mod_bitfields
    {
        uint32_t MOD : 16; //!< [15:0] PDB Modulus
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_mod_t;
#endif

/*!
 * @name Constants and macros for entire PDB_MOD register
 */
//@{
#define HW_PDB_MOD_ADDR      (REGS_PDB_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_MOD           (*(__IO hw_pdb_mod_t *) HW_PDB_MOD_ADDR)
#define HW_PDB_MOD_RD()      (HW_PDB_MOD.U)
#define HW_PDB_MOD_WR(v)     (HW_PDB_MOD.U = (v))
#define HW_PDB_MOD_SET(v)    (HW_PDB_MOD_WR(HW_PDB_MOD_RD() |  (v)))
#define HW_PDB_MOD_CLR(v)    (HW_PDB_MOD_WR(HW_PDB_MOD_RD() & ~(v)))
#define HW_PDB_MOD_TOG(v)    (HW_PDB_MOD_WR(HW_PDB_MOD_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_MOD bitfields
 */

/*! @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it will be reset back
 * to zero. If the PDB is in Continuous mode, the count begins anew. Reading this field returns the
 * value of the internal register that is effective for the current cycle of PDB.
 */
//@{
#define BP_PDB_MOD_MOD      (0U)      //!< Bit position for PDB_MOD_MOD.
#define BM_PDB_MOD_MOD      (0x0000ffffU)  //!< Bit mask for PDB_MOD_MOD.
#define BS_PDB_MOD_MOD      (16U)  //!< Bitfield size in bits for PDB_MOD_MOD.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_MOD_MOD field.
#define BR_PDB_MOD_MOD()   (HW_PDB_MOD.B.MOD)
#endif

//! @brief Format value for bitfield PDB_MOD_MOD.
#define BF_PDB_MOD_MOD(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_MOD_MOD), uint32_t) & BM_PDB_MOD_MOD)

#ifndef __LANGUAGE_ASM__
//! @brief Set the MOD field to a new value.
#define BW_PDB_MOD_MOD(v)   (HW_PDB_MOD_WR((HW_PDB_MOD_RD() & ~BM_PDB_MOD_MOD) | BF_PDB_MOD_MOD(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CNT - Counter register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_cnt
{
    uint32_t U;
    struct _hw_pdb_cnt_bitfields
    {
        uint32_t CNT : 16; //!< [15:0] PDB Counter
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_cnt_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CNT register
 */
//@{
#define HW_PDB_CNT_ADDR      (REGS_PDB_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CNT           (*(__I hw_pdb_cnt_t *) HW_PDB_CNT_ADDR)
#define HW_PDB_CNT_RD()      (HW_PDB_CNT.U)
#endif
//@}

/*
 * constants & macros for individual PDB_CNT bitfields
 */

/*! @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
//@{
#define BP_PDB_CNT_CNT      (0U)      //!< Bit position for PDB_CNT_CNT.
#define BM_PDB_CNT_CNT      (0x0000ffffU)  //!< Bit mask for PDB_CNT_CNT.
#define BS_PDB_CNT_CNT      (16U)  //!< Bitfield size in bits for PDB_CNT_CNT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CNT_CNT field.
#define BR_PDB_CNT_CNT()   (HW_PDB_CNT.B.CNT)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_IDLY - Interrupt Delay register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000ffffU
 */
typedef union _hw_pdb_idly
{
    uint32_t U;
    struct _hw_pdb_idly_bitfields
    {
        uint32_t IDLY : 16; //!< [15:0] PDB Interrupt Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_idly_t;
#endif

/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
//@{
#define HW_PDB_IDLY_ADDR      (REGS_PDB_BASE + 0xcU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_IDLY           (*(__IO hw_pdb_idly_t *) HW_PDB_IDLY_ADDR)
#define HW_PDB_IDLY_RD()      (HW_PDB_IDLY.U)
#define HW_PDB_IDLY_WR(v)     (HW_PDB_IDLY.U = (v))
#define HW_PDB_IDLY_SET(v)    (HW_PDB_IDLY_WR(HW_PDB_IDLY_RD() |  (v)))
#define HW_PDB_IDLY_CLR(v)    (HW_PDB_IDLY_WR(HW_PDB_IDLY_RD() & ~(v)))
#define HW_PDB_IDLY_TOG(v)    (HW_PDB_IDLY_WR(HW_PDB_IDLY_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_IDLY bitfields
 */

/*! @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to schedule an
 * independent interrupt at some point in the PDB cycle. If enabled, a PDB interrupt is generated,
 * when the counter is equal to the IDLY. Reading this field returns the value of internal register
 * that is effective for the current cycle of the PDB.
 */
//@{
#define BP_PDB_IDLY_IDLY      (0U)      //!< Bit position for PDB_IDLY_IDLY.
#define BM_PDB_IDLY_IDLY      (0x0000ffffU)  //!< Bit mask for PDB_IDLY_IDLY.
#define BS_PDB_IDLY_IDLY      (16U)  //!< Bitfield size in bits for PDB_IDLY_IDLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_IDLY_IDLY field.
#define BR_PDB_IDLY_IDLY()   (HW_PDB_IDLY.B.IDLY)
#endif

//! @brief Format value for bitfield PDB_IDLY_IDLY.
#define BF_PDB_IDLY_IDLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_IDLY_IDLY), uint32_t) & BM_PDB_IDLY_IDLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IDLY field to a new value.
#define BW_PDB_IDLY_IDLY(v)   (HW_PDB_IDLY_WR((HW_PDB_IDLY_RD() & ~BM_PDB_IDLY_IDLY) | BF_PDB_IDLY_IDLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH0C1 - Channel n Control register 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH0C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register control the
 * functionality of each PDB channel operation.
 */
typedef union _hw_pdb_ch0c1
{
    uint32_t U;
    struct _hw_pdb_ch0c1_bitfields
    {
        uint32_t EN : 8; //!< [7:0] PDB Channel Pre-Trigger Enable
        uint32_t TOS : 8; //!< [15:8] PDB Channel Pre-Trigger Output Select
        uint32_t BB : 8; //!< [23:16] PDB Channel Pre-Trigger Back-to-Back Operation Enable
        uint32_t RESERVED0 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch0c1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH0C1 register
 */
//@{
#define HW_PDB_CH0C1_ADDR      (REGS_PDB_BASE + 0x10U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH0C1           (*(__IO hw_pdb_ch0c1_t *) HW_PDB_CH0C1_ADDR)
#define HW_PDB_CH0C1_RD()      (HW_PDB_CH0C1.U)
#define HW_PDB_CH0C1_WR(v)     (HW_PDB_CH0C1.U = (v))
#define HW_PDB_CH0C1_SET(v)    (HW_PDB_CH0C1_WR(HW_PDB_CH0C1_RD() |  (v)))
#define HW_PDB_CH0C1_CLR(v)    (HW_PDB_CH0C1_WR(HW_PDB_CH0C1_RD() & ~(v)))
#define HW_PDB_CH0C1_TOG(v)    (HW_PDB_CH0C1_WR(HW_PDB_CH0C1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH0C1 bitfields
 */

/*! @name Register PDB_CH0C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
//@{
#define BP_PDB_CH0C1_EN      (0U)      //!< Bit position for PDB_CH0C1_EN.
#define BM_PDB_CH0C1_EN      (0x000000ffU)  //!< Bit mask for PDB_CH0C1_EN.
#define BS_PDB_CH0C1_EN      (8U)  //!< Bitfield size in bits for PDB_CH0C1_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0C1_EN field.
#define BR_PDB_CH0C1_EN()   (HW_PDB_CH0C1.B.EN)
#endif

//! @brief Format value for bitfield PDB_CH0C1_EN.
#define BF_PDB_CH0C1_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0C1_EN), uint32_t) & BM_PDB_CH0C1_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EN field to a new value.
#define BW_PDB_CH0C1_EN(v)   (HW_PDB_CH0C1_WR((HW_PDB_CH0C1_RD() & ~BM_PDB_CH0C1_EN) | BF_PDB_CH0C1_EN(v)))
#endif
//@}

/*! @name Register PDB_CH0C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral
 *     clock cycle after a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SWTRIG is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register
 *     plus one peripheral clock cycle after a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SETRIG is written with 1.
 */
//@{
#define BP_PDB_CH0C1_TOS      (8U)      //!< Bit position for PDB_CH0C1_TOS.
#define BM_PDB_CH0C1_TOS      (0x0000ff00U)  //!< Bit mask for PDB_CH0C1_TOS.
#define BS_PDB_CH0C1_TOS      (8U)  //!< Bitfield size in bits for PDB_CH0C1_TOS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0C1_TOS field.
#define BR_PDB_CH0C1_TOS()   (HW_PDB_CH0C1.B.TOS)
#endif

//! @brief Format value for bitfield PDB_CH0C1_TOS.
#define BF_PDB_CH0C1_TOS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0C1_TOS), uint32_t) & BM_PDB_CH0C1_TOS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOS field to a new value.
#define BW_PDB_CH0C1_TOS(v)   (HW_PDB_CH0C1_WR((HW_PDB_CH0C1_RD() & ~BM_PDB_CH0C1_TOS) | BF_PDB_CH0C1_TOS(v)))
#endif
//@}

/*! @name Register PDB_CH0C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode. Only lower M pre-
 * trigger bits are implemented in this MCU. Back-to-back operation enables the ADC conversions
 * complete to trigger the next PDB channel pre-trigger and trigger output, so that the ADC
 * conversions can be triggered on next set of configuration and results registers. Application code
 * must only enable the back-to-back operation of the PDB pre-triggers at the leading of the back-
 * to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
//@{
#define BP_PDB_CH0C1_BB      (16U)      //!< Bit position for PDB_CH0C1_BB.
#define BM_PDB_CH0C1_BB      (0x00ff0000U)  //!< Bit mask for PDB_CH0C1_BB.
#define BS_PDB_CH0C1_BB      (8U)  //!< Bitfield size in bits for PDB_CH0C1_BB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0C1_BB field.
#define BR_PDB_CH0C1_BB()   (HW_PDB_CH0C1.B.BB)
#endif

//! @brief Format value for bitfield PDB_CH0C1_BB.
#define BF_PDB_CH0C1_BB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0C1_BB), uint32_t) & BM_PDB_CH0C1_BB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BB field to a new value.
#define BW_PDB_CH0C1_BB(v)   (HW_PDB_CH0C1_WR((HW_PDB_CH0C1_RD() & ~BM_PDB_CH0C1_BB) | BF_PDB_CH0C1_BB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH0S - Channel n Status register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH0S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch0s
{
    uint32_t U;
    struct _hw_pdb_ch0s_bitfields
    {
        uint32_t ERR : 8; //!< [7:0] PDB Channel Sequence Error Flags
        uint32_t RESERVED0 : 8; //!< [15:8] 
        uint32_t CF : 8; //!< [23:16] PDB Channel Flags
        uint32_t RESERVED1 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch0s_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH0S register
 */
//@{
#define HW_PDB_CH0S_ADDR      (REGS_PDB_BASE + 0x14U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH0S           (*(__IO hw_pdb_ch0s_t *) HW_PDB_CH0S_ADDR)
#define HW_PDB_CH0S_RD()      (HW_PDB_CH0S.U)
#define HW_PDB_CH0S_WR(v)     (HW_PDB_CH0S.U = (v))
#define HW_PDB_CH0S_SET(v)    (HW_PDB_CH0S_WR(HW_PDB_CH0S_RD() |  (v)))
#define HW_PDB_CH0S_CLR(v)    (HW_PDB_CH0S_WR(HW_PDB_CH0S_RD() & ~(v)))
#define HW_PDB_CH0S_TOG(v)    (HW_PDB_CH0S_WR(HW_PDB_CH0S_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH0S bitfields
 */

/*! @name Register PDB_CH0S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for
 *     a conversion by one pre-trigger from PDB channel n . When one conversion, which is triggered
 *     by one of the pre-triggers from PDB channel n , is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing
 *     0’s to clear the sequence error flags.
 */
//@{
#define BP_PDB_CH0S_ERR      (0U)      //!< Bit position for PDB_CH0S_ERR.
#define BM_PDB_CH0S_ERR      (0x000000ffU)  //!< Bit mask for PDB_CH0S_ERR.
#define BS_PDB_CH0S_ERR      (8U)  //!< Bitfield size in bits for PDB_CH0S_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0S_ERR field.
#define BR_PDB_CH0S_ERR()   (HW_PDB_CH0S.B.ERR)
#endif

//! @brief Format value for bitfield PDB_CH0S_ERR.
#define BF_PDB_CH0S_ERR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0S_ERR), uint32_t) & BM_PDB_CH0S_ERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR field to a new value.
#define BW_PDB_CH0S_ERR(v)   (HW_PDB_CH0S_WR((HW_PDB_CH0S_RD() & ~BM_PDB_CH0S_ERR) | BF_PDB_CH0S_ERR(v)))
#endif
//@}

/*! @name Register PDB_CH0S, field CF[23:16] (RW)
 *
 * The CF[ m ] bit is set when the PDB counter matches the CH n DLY m . Write 0 to clear these bits.
 */
//@{
#define BP_PDB_CH0S_CF      (16U)      //!< Bit position for PDB_CH0S_CF.
#define BM_PDB_CH0S_CF      (0x00ff0000U)  //!< Bit mask for PDB_CH0S_CF.
#define BS_PDB_CH0S_CF      (8U)  //!< Bitfield size in bits for PDB_CH0S_CF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0S_CF field.
#define BR_PDB_CH0S_CF()   (HW_PDB_CH0S.B.CF)
#endif

//! @brief Format value for bitfield PDB_CH0S_CF.
#define BF_PDB_CH0S_CF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0S_CF), uint32_t) & BM_PDB_CH0S_CF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CF field to a new value.
#define BW_PDB_CH0S_CF(v)   (HW_PDB_CH0S_WR((HW_PDB_CH0S_RD() & ~BM_PDB_CH0S_CF) | BF_PDB_CH0S_CF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH0DLY0 - Channel n Delay 0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH0DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch0dly0
{
    uint32_t U;
    struct _hw_pdb_ch0dly0_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch0dly0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH0DLY0 register
 */
//@{
#define HW_PDB_CH0DLY0_ADDR      (REGS_PDB_BASE + 0x18U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH0DLY0           (*(__IO hw_pdb_ch0dly0_t *) HW_PDB_CH0DLY0_ADDR)
#define HW_PDB_CH0DLY0_RD()      (HW_PDB_CH0DLY0.U)
#define HW_PDB_CH0DLY0_WR(v)     (HW_PDB_CH0DLY0.U = (v))
#define HW_PDB_CH0DLY0_SET(v)    (HW_PDB_CH0DLY0_WR(HW_PDB_CH0DLY0_RD() |  (v)))
#define HW_PDB_CH0DLY0_CLR(v)    (HW_PDB_CH0DLY0_WR(HW_PDB_CH0DLY0_RD() & ~(v)))
#define HW_PDB_CH0DLY0_TOG(v)    (HW_PDB_CH0DLY0_WR(HW_PDB_CH0DLY0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH0DLY0 bitfields
 */

/*! @name Register PDB_CH0DLY0, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH0DLY0_DLY      (0U)      //!< Bit position for PDB_CH0DLY0_DLY.
#define BM_PDB_CH0DLY0_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH0DLY0_DLY.
#define BS_PDB_CH0DLY0_DLY      (16U)  //!< Bitfield size in bits for PDB_CH0DLY0_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0DLY0_DLY field.
#define BR_PDB_CH0DLY0_DLY()   (HW_PDB_CH0DLY0.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH0DLY0_DLY.
#define BF_PDB_CH0DLY0_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0DLY0_DLY), uint32_t) & BM_PDB_CH0DLY0_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH0DLY0_DLY(v)   (HW_PDB_CH0DLY0_WR((HW_PDB_CH0DLY0_RD() & ~BM_PDB_CH0DLY0_DLY) | BF_PDB_CH0DLY0_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH0DLY1 - Channel n Delay 1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH0DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch0dly1
{
    uint32_t U;
    struct _hw_pdb_ch0dly1_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch0dly1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH0DLY1 register
 */
//@{
#define HW_PDB_CH0DLY1_ADDR      (REGS_PDB_BASE + 0x1cU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH0DLY1           (*(__IO hw_pdb_ch0dly1_t *) HW_PDB_CH0DLY1_ADDR)
#define HW_PDB_CH0DLY1_RD()      (HW_PDB_CH0DLY1.U)
#define HW_PDB_CH0DLY1_WR(v)     (HW_PDB_CH0DLY1.U = (v))
#define HW_PDB_CH0DLY1_SET(v)    (HW_PDB_CH0DLY1_WR(HW_PDB_CH0DLY1_RD() |  (v)))
#define HW_PDB_CH0DLY1_CLR(v)    (HW_PDB_CH0DLY1_WR(HW_PDB_CH0DLY1_RD() & ~(v)))
#define HW_PDB_CH0DLY1_TOG(v)    (HW_PDB_CH0DLY1_WR(HW_PDB_CH0DLY1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH0DLY1 bitfields
 */

/*! @name Register PDB_CH0DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH0DLY1_DLY      (0U)      //!< Bit position for PDB_CH0DLY1_DLY.
#define BM_PDB_CH0DLY1_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH0DLY1_DLY.
#define BS_PDB_CH0DLY1_DLY      (16U)  //!< Bitfield size in bits for PDB_CH0DLY1_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH0DLY1_DLY field.
#define BR_PDB_CH0DLY1_DLY()   (HW_PDB_CH0DLY1.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH0DLY1_DLY.
#define BF_PDB_CH0DLY1_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH0DLY1_DLY), uint32_t) & BM_PDB_CH0DLY1_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH0DLY1_DLY(v)   (HW_PDB_CH0DLY1_WR((HW_PDB_CH0DLY1_RD() & ~BM_PDB_CH0DLY1_DLY) | BF_PDB_CH0DLY1_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH1C1 - Channel n Control register 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH1C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register control the
 * functionality of each PDB channel operation.
 */
typedef union _hw_pdb_ch1c1
{
    uint32_t U;
    struct _hw_pdb_ch1c1_bitfields
    {
        uint32_t EN : 8; //!< [7:0] PDB Channel Pre-Trigger Enable
        uint32_t TOS : 8; //!< [15:8] PDB Channel Pre-Trigger Output Select
        uint32_t BB : 8; //!< [23:16] PDB Channel Pre-Trigger Back-to-Back Operation Enable
        uint32_t RESERVED0 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch1c1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH1C1 register
 */
//@{
#define HW_PDB_CH1C1_ADDR      (REGS_PDB_BASE + 0x38U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH1C1           (*(__IO hw_pdb_ch1c1_t *) HW_PDB_CH1C1_ADDR)
#define HW_PDB_CH1C1_RD()      (HW_PDB_CH1C1.U)
#define HW_PDB_CH1C1_WR(v)     (HW_PDB_CH1C1.U = (v))
#define HW_PDB_CH1C1_SET(v)    (HW_PDB_CH1C1_WR(HW_PDB_CH1C1_RD() |  (v)))
#define HW_PDB_CH1C1_CLR(v)    (HW_PDB_CH1C1_WR(HW_PDB_CH1C1_RD() & ~(v)))
#define HW_PDB_CH1C1_TOG(v)    (HW_PDB_CH1C1_WR(HW_PDB_CH1C1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH1C1 bitfields
 */

/*! @name Register PDB_CH1C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
//@{
#define BP_PDB_CH1C1_EN      (0U)      //!< Bit position for PDB_CH1C1_EN.
#define BM_PDB_CH1C1_EN      (0x000000ffU)  //!< Bit mask for PDB_CH1C1_EN.
#define BS_PDB_CH1C1_EN      (8U)  //!< Bitfield size in bits for PDB_CH1C1_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1C1_EN field.
#define BR_PDB_CH1C1_EN()   (HW_PDB_CH1C1.B.EN)
#endif

//! @brief Format value for bitfield PDB_CH1C1_EN.
#define BF_PDB_CH1C1_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1C1_EN), uint32_t) & BM_PDB_CH1C1_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EN field to a new value.
#define BW_PDB_CH1C1_EN(v)   (HW_PDB_CH1C1_WR((HW_PDB_CH1C1_RD() & ~BM_PDB_CH1C1_EN) | BF_PDB_CH1C1_EN(v)))
#endif
//@}

/*! @name Register PDB_CH1C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral
 *     clock cycle after a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SWTRIG is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register
 *     plus one peripheral clock cycle after a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SETRIG is written with 1.
 */
//@{
#define BP_PDB_CH1C1_TOS      (8U)      //!< Bit position for PDB_CH1C1_TOS.
#define BM_PDB_CH1C1_TOS      (0x0000ff00U)  //!< Bit mask for PDB_CH1C1_TOS.
#define BS_PDB_CH1C1_TOS      (8U)  //!< Bitfield size in bits for PDB_CH1C1_TOS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1C1_TOS field.
#define BR_PDB_CH1C1_TOS()   (HW_PDB_CH1C1.B.TOS)
#endif

//! @brief Format value for bitfield PDB_CH1C1_TOS.
#define BF_PDB_CH1C1_TOS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1C1_TOS), uint32_t) & BM_PDB_CH1C1_TOS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOS field to a new value.
#define BW_PDB_CH1C1_TOS(v)   (HW_PDB_CH1C1_WR((HW_PDB_CH1C1_RD() & ~BM_PDB_CH1C1_TOS) | BF_PDB_CH1C1_TOS(v)))
#endif
//@}

/*! @name Register PDB_CH1C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode. Only lower M pre-
 * trigger bits are implemented in this MCU. Back-to-back operation enables the ADC conversions
 * complete to trigger the next PDB channel pre-trigger and trigger output, so that the ADC
 * conversions can be triggered on next set of configuration and results registers. Application code
 * must only enable the back-to-back operation of the PDB pre-triggers at the leading of the back-
 * to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
//@{
#define BP_PDB_CH1C1_BB      (16U)      //!< Bit position for PDB_CH1C1_BB.
#define BM_PDB_CH1C1_BB      (0x00ff0000U)  //!< Bit mask for PDB_CH1C1_BB.
#define BS_PDB_CH1C1_BB      (8U)  //!< Bitfield size in bits for PDB_CH1C1_BB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1C1_BB field.
#define BR_PDB_CH1C1_BB()   (HW_PDB_CH1C1.B.BB)
#endif

//! @brief Format value for bitfield PDB_CH1C1_BB.
#define BF_PDB_CH1C1_BB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1C1_BB), uint32_t) & BM_PDB_CH1C1_BB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BB field to a new value.
#define BW_PDB_CH1C1_BB(v)   (HW_PDB_CH1C1_WR((HW_PDB_CH1C1_RD() & ~BM_PDB_CH1C1_BB) | BF_PDB_CH1C1_BB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH1S - Channel n Status register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH1S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch1s
{
    uint32_t U;
    struct _hw_pdb_ch1s_bitfields
    {
        uint32_t ERR : 8; //!< [7:0] PDB Channel Sequence Error Flags
        uint32_t RESERVED0 : 8; //!< [15:8] 
        uint32_t CF : 8; //!< [23:16] PDB Channel Flags
        uint32_t RESERVED1 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch1s_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH1S register
 */
//@{
#define HW_PDB_CH1S_ADDR      (REGS_PDB_BASE + 0x3cU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH1S           (*(__IO hw_pdb_ch1s_t *) HW_PDB_CH1S_ADDR)
#define HW_PDB_CH1S_RD()      (HW_PDB_CH1S.U)
#define HW_PDB_CH1S_WR(v)     (HW_PDB_CH1S.U = (v))
#define HW_PDB_CH1S_SET(v)    (HW_PDB_CH1S_WR(HW_PDB_CH1S_RD() |  (v)))
#define HW_PDB_CH1S_CLR(v)    (HW_PDB_CH1S_WR(HW_PDB_CH1S_RD() & ~(v)))
#define HW_PDB_CH1S_TOG(v)    (HW_PDB_CH1S_WR(HW_PDB_CH1S_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH1S bitfields
 */

/*! @name Register PDB_CH1S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for
 *     a conversion by one pre-trigger from PDB channel n . When one conversion, which is triggered
 *     by one of the pre-triggers from PDB channel n , is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing
 *     0’s to clear the sequence error flags.
 */
//@{
#define BP_PDB_CH1S_ERR      (0U)      //!< Bit position for PDB_CH1S_ERR.
#define BM_PDB_CH1S_ERR      (0x000000ffU)  //!< Bit mask for PDB_CH1S_ERR.
#define BS_PDB_CH1S_ERR      (8U)  //!< Bitfield size in bits for PDB_CH1S_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1S_ERR field.
#define BR_PDB_CH1S_ERR()   (HW_PDB_CH1S.B.ERR)
#endif

//! @brief Format value for bitfield PDB_CH1S_ERR.
#define BF_PDB_CH1S_ERR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1S_ERR), uint32_t) & BM_PDB_CH1S_ERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR field to a new value.
#define BW_PDB_CH1S_ERR(v)   (HW_PDB_CH1S_WR((HW_PDB_CH1S_RD() & ~BM_PDB_CH1S_ERR) | BF_PDB_CH1S_ERR(v)))
#endif
//@}

/*! @name Register PDB_CH1S, field CF[23:16] (RW)
 *
 * The CF[ m ] bit is set when the PDB counter matches the CH n DLY m . Write 0 to clear these bits.
 */
//@{
#define BP_PDB_CH1S_CF      (16U)      //!< Bit position for PDB_CH1S_CF.
#define BM_PDB_CH1S_CF      (0x00ff0000U)  //!< Bit mask for PDB_CH1S_CF.
#define BS_PDB_CH1S_CF      (8U)  //!< Bitfield size in bits for PDB_CH1S_CF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1S_CF field.
#define BR_PDB_CH1S_CF()   (HW_PDB_CH1S.B.CF)
#endif

//! @brief Format value for bitfield PDB_CH1S_CF.
#define BF_PDB_CH1S_CF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1S_CF), uint32_t) & BM_PDB_CH1S_CF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CF field to a new value.
#define BW_PDB_CH1S_CF(v)   (HW_PDB_CH1S_WR((HW_PDB_CH1S_RD() & ~BM_PDB_CH1S_CF) | BF_PDB_CH1S_CF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH1DLY0 - Channel n Delay 0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH1DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch1dly0
{
    uint32_t U;
    struct _hw_pdb_ch1dly0_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch1dly0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH1DLY0 register
 */
//@{
#define HW_PDB_CH1DLY0_ADDR      (REGS_PDB_BASE + 0x40U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH1DLY0           (*(__IO hw_pdb_ch1dly0_t *) HW_PDB_CH1DLY0_ADDR)
#define HW_PDB_CH1DLY0_RD()      (HW_PDB_CH1DLY0.U)
#define HW_PDB_CH1DLY0_WR(v)     (HW_PDB_CH1DLY0.U = (v))
#define HW_PDB_CH1DLY0_SET(v)    (HW_PDB_CH1DLY0_WR(HW_PDB_CH1DLY0_RD() |  (v)))
#define HW_PDB_CH1DLY0_CLR(v)    (HW_PDB_CH1DLY0_WR(HW_PDB_CH1DLY0_RD() & ~(v)))
#define HW_PDB_CH1DLY0_TOG(v)    (HW_PDB_CH1DLY0_WR(HW_PDB_CH1DLY0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH1DLY0 bitfields
 */

/*! @name Register PDB_CH1DLY0, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH1DLY0_DLY      (0U)      //!< Bit position for PDB_CH1DLY0_DLY.
#define BM_PDB_CH1DLY0_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH1DLY0_DLY.
#define BS_PDB_CH1DLY0_DLY      (16U)  //!< Bitfield size in bits for PDB_CH1DLY0_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1DLY0_DLY field.
#define BR_PDB_CH1DLY0_DLY()   (HW_PDB_CH1DLY0.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH1DLY0_DLY.
#define BF_PDB_CH1DLY0_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1DLY0_DLY), uint32_t) & BM_PDB_CH1DLY0_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH1DLY0_DLY(v)   (HW_PDB_CH1DLY0_WR((HW_PDB_CH1DLY0_RD() & ~BM_PDB_CH1DLY0_DLY) | BF_PDB_CH1DLY0_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH1DLY1 - Channel n Delay 1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH1DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch1dly1
{
    uint32_t U;
    struct _hw_pdb_ch1dly1_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch1dly1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH1DLY1 register
 */
//@{
#define HW_PDB_CH1DLY1_ADDR      (REGS_PDB_BASE + 0x44U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH1DLY1           (*(__IO hw_pdb_ch1dly1_t *) HW_PDB_CH1DLY1_ADDR)
#define HW_PDB_CH1DLY1_RD()      (HW_PDB_CH1DLY1.U)
#define HW_PDB_CH1DLY1_WR(v)     (HW_PDB_CH1DLY1.U = (v))
#define HW_PDB_CH1DLY1_SET(v)    (HW_PDB_CH1DLY1_WR(HW_PDB_CH1DLY1_RD() |  (v)))
#define HW_PDB_CH1DLY1_CLR(v)    (HW_PDB_CH1DLY1_WR(HW_PDB_CH1DLY1_RD() & ~(v)))
#define HW_PDB_CH1DLY1_TOG(v)    (HW_PDB_CH1DLY1_WR(HW_PDB_CH1DLY1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH1DLY1 bitfields
 */

/*! @name Register PDB_CH1DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH1DLY1_DLY      (0U)      //!< Bit position for PDB_CH1DLY1_DLY.
#define BM_PDB_CH1DLY1_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH1DLY1_DLY.
#define BS_PDB_CH1DLY1_DLY      (16U)  //!< Bitfield size in bits for PDB_CH1DLY1_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH1DLY1_DLY field.
#define BR_PDB_CH1DLY1_DLY()   (HW_PDB_CH1DLY1.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH1DLY1_DLY.
#define BF_PDB_CH1DLY1_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH1DLY1_DLY), uint32_t) & BM_PDB_CH1DLY1_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH1DLY1_DLY(v)   (HW_PDB_CH1DLY1_WR((HW_PDB_CH1DLY1_RD() & ~BM_PDB_CH1DLY1_DLY) | BF_PDB_CH1DLY1_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH2C1 - Channel n Control register 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH2C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register control the
 * functionality of each PDB channel operation.
 */
typedef union _hw_pdb_ch2c1
{
    uint32_t U;
    struct _hw_pdb_ch2c1_bitfields
    {
        uint32_t EN : 8; //!< [7:0] PDB Channel Pre-Trigger Enable
        uint32_t TOS : 8; //!< [15:8] PDB Channel Pre-Trigger Output Select
        uint32_t BB : 8; //!< [23:16] PDB Channel Pre-Trigger Back-to-Back Operation Enable
        uint32_t RESERVED0 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch2c1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH2C1 register
 */
//@{
#define HW_PDB_CH2C1_ADDR      (REGS_PDB_BASE + 0x60U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH2C1           (*(__IO hw_pdb_ch2c1_t *) HW_PDB_CH2C1_ADDR)
#define HW_PDB_CH2C1_RD()      (HW_PDB_CH2C1.U)
#define HW_PDB_CH2C1_WR(v)     (HW_PDB_CH2C1.U = (v))
#define HW_PDB_CH2C1_SET(v)    (HW_PDB_CH2C1_WR(HW_PDB_CH2C1_RD() |  (v)))
#define HW_PDB_CH2C1_CLR(v)    (HW_PDB_CH2C1_WR(HW_PDB_CH2C1_RD() & ~(v)))
#define HW_PDB_CH2C1_TOG(v)    (HW_PDB_CH2C1_WR(HW_PDB_CH2C1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH2C1 bitfields
 */

/*! @name Register PDB_CH2C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
//@{
#define BP_PDB_CH2C1_EN      (0U)      //!< Bit position for PDB_CH2C1_EN.
#define BM_PDB_CH2C1_EN      (0x000000ffU)  //!< Bit mask for PDB_CH2C1_EN.
#define BS_PDB_CH2C1_EN      (8U)  //!< Bitfield size in bits for PDB_CH2C1_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2C1_EN field.
#define BR_PDB_CH2C1_EN()   (HW_PDB_CH2C1.B.EN)
#endif

//! @brief Format value for bitfield PDB_CH2C1_EN.
#define BF_PDB_CH2C1_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2C1_EN), uint32_t) & BM_PDB_CH2C1_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EN field to a new value.
#define BW_PDB_CH2C1_EN(v)   (HW_PDB_CH2C1_WR((HW_PDB_CH2C1_RD() & ~BM_PDB_CH2C1_EN) | BF_PDB_CH2C1_EN(v)))
#endif
//@}

/*! @name Register PDB_CH2C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral
 *     clock cycle after a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SWTRIG is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register
 *     plus one peripheral clock cycle after a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SETRIG is written with 1.
 */
//@{
#define BP_PDB_CH2C1_TOS      (8U)      //!< Bit position for PDB_CH2C1_TOS.
#define BM_PDB_CH2C1_TOS      (0x0000ff00U)  //!< Bit mask for PDB_CH2C1_TOS.
#define BS_PDB_CH2C1_TOS      (8U)  //!< Bitfield size in bits for PDB_CH2C1_TOS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2C1_TOS field.
#define BR_PDB_CH2C1_TOS()   (HW_PDB_CH2C1.B.TOS)
#endif

//! @brief Format value for bitfield PDB_CH2C1_TOS.
#define BF_PDB_CH2C1_TOS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2C1_TOS), uint32_t) & BM_PDB_CH2C1_TOS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOS field to a new value.
#define BW_PDB_CH2C1_TOS(v)   (HW_PDB_CH2C1_WR((HW_PDB_CH2C1_RD() & ~BM_PDB_CH2C1_TOS) | BF_PDB_CH2C1_TOS(v)))
#endif
//@}

/*! @name Register PDB_CH2C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode. Only lower M pre-
 * trigger bits are implemented in this MCU. Back-to-back operation enables the ADC conversions
 * complete to trigger the next PDB channel pre-trigger and trigger output, so that the ADC
 * conversions can be triggered on next set of configuration and results registers. Application code
 * must only enable the back-to-back operation of the PDB pre-triggers at the leading of the back-
 * to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
//@{
#define BP_PDB_CH2C1_BB      (16U)      //!< Bit position for PDB_CH2C1_BB.
#define BM_PDB_CH2C1_BB      (0x00ff0000U)  //!< Bit mask for PDB_CH2C1_BB.
#define BS_PDB_CH2C1_BB      (8U)  //!< Bitfield size in bits for PDB_CH2C1_BB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2C1_BB field.
#define BR_PDB_CH2C1_BB()   (HW_PDB_CH2C1.B.BB)
#endif

//! @brief Format value for bitfield PDB_CH2C1_BB.
#define BF_PDB_CH2C1_BB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2C1_BB), uint32_t) & BM_PDB_CH2C1_BB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BB field to a new value.
#define BW_PDB_CH2C1_BB(v)   (HW_PDB_CH2C1_WR((HW_PDB_CH2C1_RD() & ~BM_PDB_CH2C1_BB) | BF_PDB_CH2C1_BB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH2S - Channel n Status register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH2S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch2s
{
    uint32_t U;
    struct _hw_pdb_ch2s_bitfields
    {
        uint32_t ERR : 8; //!< [7:0] PDB Channel Sequence Error Flags
        uint32_t RESERVED0 : 8; //!< [15:8] 
        uint32_t CF : 8; //!< [23:16] PDB Channel Flags
        uint32_t RESERVED1 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch2s_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH2S register
 */
//@{
#define HW_PDB_CH2S_ADDR      (REGS_PDB_BASE + 0x64U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH2S           (*(__IO hw_pdb_ch2s_t *) HW_PDB_CH2S_ADDR)
#define HW_PDB_CH2S_RD()      (HW_PDB_CH2S.U)
#define HW_PDB_CH2S_WR(v)     (HW_PDB_CH2S.U = (v))
#define HW_PDB_CH2S_SET(v)    (HW_PDB_CH2S_WR(HW_PDB_CH2S_RD() |  (v)))
#define HW_PDB_CH2S_CLR(v)    (HW_PDB_CH2S_WR(HW_PDB_CH2S_RD() & ~(v)))
#define HW_PDB_CH2S_TOG(v)    (HW_PDB_CH2S_WR(HW_PDB_CH2S_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH2S bitfields
 */

/*! @name Register PDB_CH2S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for
 *     a conversion by one pre-trigger from PDB channel n . When one conversion, which is triggered
 *     by one of the pre-triggers from PDB channel n , is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing
 *     0’s to clear the sequence error flags.
 */
//@{
#define BP_PDB_CH2S_ERR      (0U)      //!< Bit position for PDB_CH2S_ERR.
#define BM_PDB_CH2S_ERR      (0x000000ffU)  //!< Bit mask for PDB_CH2S_ERR.
#define BS_PDB_CH2S_ERR      (8U)  //!< Bitfield size in bits for PDB_CH2S_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2S_ERR field.
#define BR_PDB_CH2S_ERR()   (HW_PDB_CH2S.B.ERR)
#endif

//! @brief Format value for bitfield PDB_CH2S_ERR.
#define BF_PDB_CH2S_ERR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2S_ERR), uint32_t) & BM_PDB_CH2S_ERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR field to a new value.
#define BW_PDB_CH2S_ERR(v)   (HW_PDB_CH2S_WR((HW_PDB_CH2S_RD() & ~BM_PDB_CH2S_ERR) | BF_PDB_CH2S_ERR(v)))
#endif
//@}

/*! @name Register PDB_CH2S, field CF[23:16] (RW)
 *
 * The CF[ m ] bit is set when the PDB counter matches the CH n DLY m . Write 0 to clear these bits.
 */
//@{
#define BP_PDB_CH2S_CF      (16U)      //!< Bit position for PDB_CH2S_CF.
#define BM_PDB_CH2S_CF      (0x00ff0000U)  //!< Bit mask for PDB_CH2S_CF.
#define BS_PDB_CH2S_CF      (8U)  //!< Bitfield size in bits for PDB_CH2S_CF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2S_CF field.
#define BR_PDB_CH2S_CF()   (HW_PDB_CH2S.B.CF)
#endif

//! @brief Format value for bitfield PDB_CH2S_CF.
#define BF_PDB_CH2S_CF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2S_CF), uint32_t) & BM_PDB_CH2S_CF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CF field to a new value.
#define BW_PDB_CH2S_CF(v)   (HW_PDB_CH2S_WR((HW_PDB_CH2S_RD() & ~BM_PDB_CH2S_CF) | BF_PDB_CH2S_CF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH2DLY0 - Channel n Delay 0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH2DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch2dly0
{
    uint32_t U;
    struct _hw_pdb_ch2dly0_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch2dly0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH2DLY0 register
 */
//@{
#define HW_PDB_CH2DLY0_ADDR      (REGS_PDB_BASE + 0x68U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH2DLY0           (*(__IO hw_pdb_ch2dly0_t *) HW_PDB_CH2DLY0_ADDR)
#define HW_PDB_CH2DLY0_RD()      (HW_PDB_CH2DLY0.U)
#define HW_PDB_CH2DLY0_WR(v)     (HW_PDB_CH2DLY0.U = (v))
#define HW_PDB_CH2DLY0_SET(v)    (HW_PDB_CH2DLY0_WR(HW_PDB_CH2DLY0_RD() |  (v)))
#define HW_PDB_CH2DLY0_CLR(v)    (HW_PDB_CH2DLY0_WR(HW_PDB_CH2DLY0_RD() & ~(v)))
#define HW_PDB_CH2DLY0_TOG(v)    (HW_PDB_CH2DLY0_WR(HW_PDB_CH2DLY0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH2DLY0 bitfields
 */

/*! @name Register PDB_CH2DLY0, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH2DLY0_DLY      (0U)      //!< Bit position for PDB_CH2DLY0_DLY.
#define BM_PDB_CH2DLY0_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH2DLY0_DLY.
#define BS_PDB_CH2DLY0_DLY      (16U)  //!< Bitfield size in bits for PDB_CH2DLY0_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2DLY0_DLY field.
#define BR_PDB_CH2DLY0_DLY()   (HW_PDB_CH2DLY0.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH2DLY0_DLY.
#define BF_PDB_CH2DLY0_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2DLY0_DLY), uint32_t) & BM_PDB_CH2DLY0_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH2DLY0_DLY(v)   (HW_PDB_CH2DLY0_WR((HW_PDB_CH2DLY0_RD() & ~BM_PDB_CH2DLY0_DLY) | BF_PDB_CH2DLY0_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH2DLY1 - Channel n Delay 1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH2DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch2dly1
{
    uint32_t U;
    struct _hw_pdb_ch2dly1_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch2dly1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH2DLY1 register
 */
//@{
#define HW_PDB_CH2DLY1_ADDR      (REGS_PDB_BASE + 0x6cU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH2DLY1           (*(__IO hw_pdb_ch2dly1_t *) HW_PDB_CH2DLY1_ADDR)
#define HW_PDB_CH2DLY1_RD()      (HW_PDB_CH2DLY1.U)
#define HW_PDB_CH2DLY1_WR(v)     (HW_PDB_CH2DLY1.U = (v))
#define HW_PDB_CH2DLY1_SET(v)    (HW_PDB_CH2DLY1_WR(HW_PDB_CH2DLY1_RD() |  (v)))
#define HW_PDB_CH2DLY1_CLR(v)    (HW_PDB_CH2DLY1_WR(HW_PDB_CH2DLY1_RD() & ~(v)))
#define HW_PDB_CH2DLY1_TOG(v)    (HW_PDB_CH2DLY1_WR(HW_PDB_CH2DLY1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH2DLY1 bitfields
 */

/*! @name Register PDB_CH2DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH2DLY1_DLY      (0U)      //!< Bit position for PDB_CH2DLY1_DLY.
#define BM_PDB_CH2DLY1_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH2DLY1_DLY.
#define BS_PDB_CH2DLY1_DLY      (16U)  //!< Bitfield size in bits for PDB_CH2DLY1_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH2DLY1_DLY field.
#define BR_PDB_CH2DLY1_DLY()   (HW_PDB_CH2DLY1.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH2DLY1_DLY.
#define BF_PDB_CH2DLY1_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH2DLY1_DLY), uint32_t) & BM_PDB_CH2DLY1_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH2DLY1_DLY(v)   (HW_PDB_CH2DLY1_WR((HW_PDB_CH2DLY1_RD() & ~BM_PDB_CH2DLY1_DLY) | BF_PDB_CH2DLY1_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH3C1 - Channel n Control register 1
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH3C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register control the
 * functionality of each PDB channel operation.
 */
typedef union _hw_pdb_ch3c1
{
    uint32_t U;
    struct _hw_pdb_ch3c1_bitfields
    {
        uint32_t EN : 8; //!< [7:0] PDB Channel Pre-Trigger Enable
        uint32_t TOS : 8; //!< [15:8] PDB Channel Pre-Trigger Output Select
        uint32_t BB : 8; //!< [23:16] PDB Channel Pre-Trigger Back-to-Back Operation Enable
        uint32_t RESERVED0 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch3c1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH3C1 register
 */
//@{
#define HW_PDB_CH3C1_ADDR      (REGS_PDB_BASE + 0x88U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH3C1           (*(__IO hw_pdb_ch3c1_t *) HW_PDB_CH3C1_ADDR)
#define HW_PDB_CH3C1_RD()      (HW_PDB_CH3C1.U)
#define HW_PDB_CH3C1_WR(v)     (HW_PDB_CH3C1.U = (v))
#define HW_PDB_CH3C1_SET(v)    (HW_PDB_CH3C1_WR(HW_PDB_CH3C1_RD() |  (v)))
#define HW_PDB_CH3C1_CLR(v)    (HW_PDB_CH3C1_WR(HW_PDB_CH3C1_RD() & ~(v)))
#define HW_PDB_CH3C1_TOG(v)    (HW_PDB_CH3C1_WR(HW_PDB_CH3C1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH3C1 bitfields
 */

/*! @name Register PDB_CH3C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
//@{
#define BP_PDB_CH3C1_EN      (0U)      //!< Bit position for PDB_CH3C1_EN.
#define BM_PDB_CH3C1_EN      (0x000000ffU)  //!< Bit mask for PDB_CH3C1_EN.
#define BS_PDB_CH3C1_EN      (8U)  //!< Bitfield size in bits for PDB_CH3C1_EN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3C1_EN field.
#define BR_PDB_CH3C1_EN()   (HW_PDB_CH3C1.B.EN)
#endif

//! @brief Format value for bitfield PDB_CH3C1_EN.
#define BF_PDB_CH3C1_EN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3C1_EN), uint32_t) & BM_PDB_CH3C1_EN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EN field to a new value.
#define BW_PDB_CH3C1_EN(v)   (HW_PDB_CH3C1_WR((HW_PDB_CH3C1_RD() & ~BM_PDB_CH3C1_EN) | BF_PDB_CH3C1_EN(v)))
#endif
//@}

/*! @name Register PDB_CH3C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger bits are implemented
 * in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral
 *     clock cycle after a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SWTRIG is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register
 *     plus one peripheral clock cycle after a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SETRIG is written with 1.
 */
//@{
#define BP_PDB_CH3C1_TOS      (8U)      //!< Bit position for PDB_CH3C1_TOS.
#define BM_PDB_CH3C1_TOS      (0x0000ff00U)  //!< Bit mask for PDB_CH3C1_TOS.
#define BS_PDB_CH3C1_TOS      (8U)  //!< Bitfield size in bits for PDB_CH3C1_TOS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3C1_TOS field.
#define BR_PDB_CH3C1_TOS()   (HW_PDB_CH3C1.B.TOS)
#endif

//! @brief Format value for bitfield PDB_CH3C1_TOS.
#define BF_PDB_CH3C1_TOS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3C1_TOS), uint32_t) & BM_PDB_CH3C1_TOS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOS field to a new value.
#define BW_PDB_CH3C1_TOS(v)   (HW_PDB_CH3C1_WR((HW_PDB_CH3C1_RD() & ~BM_PDB_CH3C1_TOS) | BF_PDB_CH3C1_TOS(v)))
#endif
//@}

/*! @name Register PDB_CH3C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode. Only lower M pre-
 * trigger bits are implemented in this MCU. Back-to-back operation enables the ADC conversions
 * complete to trigger the next PDB channel pre-trigger and trigger output, so that the ADC
 * conversions can be triggered on next set of configuration and results registers. Application code
 * must only enable the back-to-back operation of the PDB pre-triggers at the leading of the back-
 * to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
//@{
#define BP_PDB_CH3C1_BB      (16U)      //!< Bit position for PDB_CH3C1_BB.
#define BM_PDB_CH3C1_BB      (0x00ff0000U)  //!< Bit mask for PDB_CH3C1_BB.
#define BS_PDB_CH3C1_BB      (8U)  //!< Bitfield size in bits for PDB_CH3C1_BB.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3C1_BB field.
#define BR_PDB_CH3C1_BB()   (HW_PDB_CH3C1.B.BB)
#endif

//! @brief Format value for bitfield PDB_CH3C1_BB.
#define BF_PDB_CH3C1_BB(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3C1_BB), uint32_t) & BM_PDB_CH3C1_BB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the BB field to a new value.
#define BW_PDB_CH3C1_BB(v)   (HW_PDB_CH3C1_WR((HW_PDB_CH3C1_RD() & ~BM_PDB_CH3C1_BB) | BF_PDB_CH3C1_BB(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH3S - Channel n Status register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH3S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch3s
{
    uint32_t U;
    struct _hw_pdb_ch3s_bitfields
    {
        uint32_t ERR : 8; //!< [7:0] PDB Channel Sequence Error Flags
        uint32_t RESERVED0 : 8; //!< [15:8] 
        uint32_t CF : 8; //!< [23:16] PDB Channel Flags
        uint32_t RESERVED1 : 8; //!< [31:24] 
    } B;
} hw_pdb_ch3s_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH3S register
 */
//@{
#define HW_PDB_CH3S_ADDR      (REGS_PDB_BASE + 0x8cU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH3S           (*(__IO hw_pdb_ch3s_t *) HW_PDB_CH3S_ADDR)
#define HW_PDB_CH3S_RD()      (HW_PDB_CH3S.U)
#define HW_PDB_CH3S_WR(v)     (HW_PDB_CH3S.U = (v))
#define HW_PDB_CH3S_SET(v)    (HW_PDB_CH3S_WR(HW_PDB_CH3S_RD() |  (v)))
#define HW_PDB_CH3S_CLR(v)    (HW_PDB_CH3S_WR(HW_PDB_CH3S_RD() & ~(v)))
#define HW_PDB_CH3S_TOG(v)    (HW_PDB_CH3S_WR(HW_PDB_CH3S_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH3S bitfields
 */

/*! @name Register PDB_CH3S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for
 *     a conversion by one pre-trigger from PDB channel n . When one conversion, which is triggered
 *     by one of the pre-triggers from PDB channel n , is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing
 *     0’s to clear the sequence error flags.
 */
//@{
#define BP_PDB_CH3S_ERR      (0U)      //!< Bit position for PDB_CH3S_ERR.
#define BM_PDB_CH3S_ERR      (0x000000ffU)  //!< Bit mask for PDB_CH3S_ERR.
#define BS_PDB_CH3S_ERR      (8U)  //!< Bitfield size in bits for PDB_CH3S_ERR.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3S_ERR field.
#define BR_PDB_CH3S_ERR()   (HW_PDB_CH3S.B.ERR)
#endif

//! @brief Format value for bitfield PDB_CH3S_ERR.
#define BF_PDB_CH3S_ERR(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3S_ERR), uint32_t) & BM_PDB_CH3S_ERR)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ERR field to a new value.
#define BW_PDB_CH3S_ERR(v)   (HW_PDB_CH3S_WR((HW_PDB_CH3S_RD() & ~BM_PDB_CH3S_ERR) | BF_PDB_CH3S_ERR(v)))
#endif
//@}

/*! @name Register PDB_CH3S, field CF[23:16] (RW)
 *
 * The CF[ m ] bit is set when the PDB counter matches the CH n DLY m . Write 0 to clear these bits.
 */
//@{
#define BP_PDB_CH3S_CF      (16U)      //!< Bit position for PDB_CH3S_CF.
#define BM_PDB_CH3S_CF      (0x00ff0000U)  //!< Bit mask for PDB_CH3S_CF.
#define BS_PDB_CH3S_CF      (8U)  //!< Bitfield size in bits for PDB_CH3S_CF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3S_CF field.
#define BR_PDB_CH3S_CF()   (HW_PDB_CH3S.B.CF)
#endif

//! @brief Format value for bitfield PDB_CH3S_CF.
#define BF_PDB_CH3S_CF(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3S_CF), uint32_t) & BM_PDB_CH3S_CF)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CF field to a new value.
#define BW_PDB_CH3S_CF(v)   (HW_PDB_CH3S_WR((HW_PDB_CH3S_RD() & ~BM_PDB_CH3S_CF) | BF_PDB_CH3S_CF(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH3DLY0 - Channel n Delay 0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH3DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch3dly0
{
    uint32_t U;
    struct _hw_pdb_ch3dly0_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch3dly0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH3DLY0 register
 */
//@{
#define HW_PDB_CH3DLY0_ADDR      (REGS_PDB_BASE + 0x90U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH3DLY0           (*(__IO hw_pdb_ch3dly0_t *) HW_PDB_CH3DLY0_ADDR)
#define HW_PDB_CH3DLY0_RD()      (HW_PDB_CH3DLY0.U)
#define HW_PDB_CH3DLY0_WR(v)     (HW_PDB_CH3DLY0.U = (v))
#define HW_PDB_CH3DLY0_SET(v)    (HW_PDB_CH3DLY0_WR(HW_PDB_CH3DLY0_RD() |  (v)))
#define HW_PDB_CH3DLY0_CLR(v)    (HW_PDB_CH3DLY0_WR(HW_PDB_CH3DLY0_RD() & ~(v)))
#define HW_PDB_CH3DLY0_TOG(v)    (HW_PDB_CH3DLY0_WR(HW_PDB_CH3DLY0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH3DLY0 bitfields
 */

/*! @name Register PDB_CH3DLY0, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH3DLY0_DLY      (0U)      //!< Bit position for PDB_CH3DLY0_DLY.
#define BM_PDB_CH3DLY0_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH3DLY0_DLY.
#define BS_PDB_CH3DLY0_DLY      (16U)  //!< Bitfield size in bits for PDB_CH3DLY0_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3DLY0_DLY field.
#define BR_PDB_CH3DLY0_DLY()   (HW_PDB_CH3DLY0.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH3DLY0_DLY.
#define BF_PDB_CH3DLY0_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3DLY0_DLY), uint32_t) & BM_PDB_CH3DLY0_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH3DLY0_DLY(v)   (HW_PDB_CH3DLY0_WR((HW_PDB_CH3DLY0_RD() & ~BM_PDB_CH3DLY0_DLY) | BF_PDB_CH3DLY0_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_CH3DLY1 - Channel n Delay 1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_CH3DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_ch3dly1
{
    uint32_t U;
    struct _hw_pdb_ch3dly1_bitfields
    {
        uint32_t DLY : 16; //!< [15:0] PDB Channel Delay
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_ch3dly1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_CH3DLY1 register
 */
//@{
#define HW_PDB_CH3DLY1_ADDR      (REGS_PDB_BASE + 0x94U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_CH3DLY1           (*(__IO hw_pdb_ch3dly1_t *) HW_PDB_CH3DLY1_ADDR)
#define HW_PDB_CH3DLY1_RD()      (HW_PDB_CH3DLY1.U)
#define HW_PDB_CH3DLY1_WR(v)     (HW_PDB_CH3DLY1.U = (v))
#define HW_PDB_CH3DLY1_SET(v)    (HW_PDB_CH3DLY1_WR(HW_PDB_CH3DLY1_RD() |  (v)))
#define HW_PDB_CH3DLY1_CLR(v)    (HW_PDB_CH3DLY1_WR(HW_PDB_CH3DLY1_RD() & ~(v)))
#define HW_PDB_CH3DLY1_TOG(v)    (HW_PDB_CH3DLY1_WR(HW_PDB_CH3DLY1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_CH3DLY1 bitfields
 */

/*! @name Register PDB_CH3DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding pre-trigger. The pre-trigger
 * asserts when the counter is equal to DLY. Reading these bits returns the value of internal
 * register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_CH3DLY1_DLY      (0U)      //!< Bit position for PDB_CH3DLY1_DLY.
#define BM_PDB_CH3DLY1_DLY      (0x0000ffffU)  //!< Bit mask for PDB_CH3DLY1_DLY.
#define BS_PDB_CH3DLY1_DLY      (16U)  //!< Bitfield size in bits for PDB_CH3DLY1_DLY.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_CH3DLY1_DLY field.
#define BR_PDB_CH3DLY1_DLY()   (HW_PDB_CH3DLY1.B.DLY)
#endif

//! @brief Format value for bitfield PDB_CH3DLY1_DLY.
#define BF_PDB_CH3DLY1_DLY(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_CH3DLY1_DLY), uint32_t) & BM_PDB_CH3DLY1_DLY)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY field to a new value.
#define BW_PDB_CH3DLY1_DLY(v)   (HW_PDB_CH3DLY1_WR((HW_PDB_CH3DLY1_RD() & ~BM_PDB_CH3DLY1_DLY) | BF_PDB_CH3DLY1_DLY(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_DACINTC0 - DAC Interval Trigger n Control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_DACINTC0 - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacintc0
{
    uint32_t U;
    struct _hw_pdb_dacintc0_bitfields
    {
        uint32_t TOE : 1; //!< [0] DAC Interval Trigger Enable
        uint32_t EXT : 1; //!< [1] DAC External Trigger Input Enable
        uint32_t RESERVED0 : 30; //!< [31:2] 
    } B;
} hw_pdb_dacintc0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_DACINTC0 register
 */
//@{
#define HW_PDB_DACINTC0_ADDR      (REGS_PDB_BASE + 0x150U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_DACINTC0           (*(__IO hw_pdb_dacintc0_t *) HW_PDB_DACINTC0_ADDR)
#define HW_PDB_DACINTC0_RD()      (HW_PDB_DACINTC0.U)
#define HW_PDB_DACINTC0_WR(v)     (HW_PDB_DACINTC0.U = (v))
#define HW_PDB_DACINTC0_SET(v)    (HW_PDB_DACINTC0_WR(HW_PDB_DACINTC0_RD() |  (v)))
#define HW_PDB_DACINTC0_CLR(v)    (HW_PDB_DACINTC0_WR(HW_PDB_DACINTC0_RD() & ~(v)))
#define HW_PDB_DACINTC0_TOG(v)    (HW_PDB_DACINTC0_WR(HW_PDB_DACINTC0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_DACINTC0 bitfields
 */

/*! @name Register PDB_DACINTC0, field TOE[0] (RW)
 *
 * This bit enables the DAC interval trigger.
 *
 * Values:
 * - 0 - DAC interval trigger disabled.
 * - 1 - DAC interval trigger enabled.
 */
//@{
#define BP_PDB_DACINTC0_TOE      (0U)      //!< Bit position for PDB_DACINTC0_TOE.
#define BM_PDB_DACINTC0_TOE      (0x00000001U)  //!< Bit mask for PDB_DACINTC0_TOE.
#define BS_PDB_DACINTC0_TOE      (1U)  //!< Bitfield size in bits for PDB_DACINTC0_TOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINTC0_TOE field.
#define BR_PDB_DACINTC0_TOE()   (BITBAND_ACCESS32(HW_PDB_DACINTC0_ADDR, BP_PDB_DACINTC0_TOE))
#endif

//! @brief Format value for bitfield PDB_DACINTC0_TOE.
#define BF_PDB_DACINTC0_TOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINTC0_TOE), uint32_t) & BM_PDB_DACINTC0_TOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOE field to a new value.
#define BW_PDB_DACINTC0_TOE(v)   (BITBAND_ACCESS32(HW_PDB_DACINTC0_ADDR, BP_PDB_DACINTC0_TOE) = (v))
#endif
//@}

/*! @name Register PDB_DACINTC0, field EXT[1] (RW)
 *
 * Enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0 - DAC external trigger input disabled. DAC interval counter is reset and counting starts when a rising
 *     edge is detected on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - DAC external trigger input enabled. DAC interval counter is bypassed and DAC external trigger input
 *     triggers the DAC interval trigger.
 */
//@{
#define BP_PDB_DACINTC0_EXT      (1U)      //!< Bit position for PDB_DACINTC0_EXT.
#define BM_PDB_DACINTC0_EXT      (0x00000002U)  //!< Bit mask for PDB_DACINTC0_EXT.
#define BS_PDB_DACINTC0_EXT      (1U)  //!< Bitfield size in bits for PDB_DACINTC0_EXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINTC0_EXT field.
#define BR_PDB_DACINTC0_EXT()   (BITBAND_ACCESS32(HW_PDB_DACINTC0_ADDR, BP_PDB_DACINTC0_EXT))
#endif

//! @brief Format value for bitfield PDB_DACINTC0_EXT.
#define BF_PDB_DACINTC0_EXT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINTC0_EXT), uint32_t) & BM_PDB_DACINTC0_EXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EXT field to a new value.
#define BW_PDB_DACINTC0_EXT(v)   (BITBAND_ACCESS32(HW_PDB_DACINTC0_ADDR, BP_PDB_DACINTC0_EXT) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_DACINT0 - DAC Interval n register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_DACINT0 - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacint0
{
    uint32_t U;
    struct _hw_pdb_dacint0_bitfields
    {
        uint32_t INT : 16; //!< [15:0] DAC Interval
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_dacint0_t;
#endif

/*!
 * @name Constants and macros for entire PDB_DACINT0 register
 */
//@{
#define HW_PDB_DACINT0_ADDR      (REGS_PDB_BASE + 0x154U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_DACINT0           (*(__IO hw_pdb_dacint0_t *) HW_PDB_DACINT0_ADDR)
#define HW_PDB_DACINT0_RD()      (HW_PDB_DACINT0.U)
#define HW_PDB_DACINT0_WR(v)     (HW_PDB_DACINT0.U = (v))
#define HW_PDB_DACINT0_SET(v)    (HW_PDB_DACINT0_WR(HW_PDB_DACINT0_RD() |  (v)))
#define HW_PDB_DACINT0_CLR(v)    (HW_PDB_DACINT0_WR(HW_PDB_DACINT0_RD() & ~(v)))
#define HW_PDB_DACINT0_TOG(v)    (HW_PDB_DACINT0_WR(HW_PDB_DACINT0_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_DACINT0 bitfields
 */

/*! @name Register PDB_DACINT0, field INT[15:0] (RW)
 *
 * Specifies the interval value for DAC interval trigger. DAC interval trigger triggers DAC[1:0]
 * update when the DAC interval counter is equal to the DACINT. Reading this field returns the value
 * of internal register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_DACINT0_INT      (0U)      //!< Bit position for PDB_DACINT0_INT.
#define BM_PDB_DACINT0_INT      (0x0000ffffU)  //!< Bit mask for PDB_DACINT0_INT.
#define BS_PDB_DACINT0_INT      (16U)  //!< Bitfield size in bits for PDB_DACINT0_INT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINT0_INT field.
#define BR_PDB_DACINT0_INT()   (HW_PDB_DACINT0.B.INT)
#endif

//! @brief Format value for bitfield PDB_DACINT0_INT.
#define BF_PDB_DACINT0_INT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINT0_INT), uint32_t) & BM_PDB_DACINT0_INT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT field to a new value.
#define BW_PDB_DACINT0_INT(v)   (HW_PDB_DACINT0_WR((HW_PDB_DACINT0_RD() & ~BM_PDB_DACINT0_INT) | BF_PDB_DACINT0_INT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_DACINTC1 - DAC Interval Trigger n Control register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_DACINTC1 - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacintc1
{
    uint32_t U;
    struct _hw_pdb_dacintc1_bitfields
    {
        uint32_t TOE : 1; //!< [0] DAC Interval Trigger Enable
        uint32_t EXT : 1; //!< [1] DAC External Trigger Input Enable
        uint32_t RESERVED0 : 30; //!< [31:2] 
    } B;
} hw_pdb_dacintc1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_DACINTC1 register
 */
//@{
#define HW_PDB_DACINTC1_ADDR      (REGS_PDB_BASE + 0x158U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_DACINTC1           (*(__IO hw_pdb_dacintc1_t *) HW_PDB_DACINTC1_ADDR)
#define HW_PDB_DACINTC1_RD()      (HW_PDB_DACINTC1.U)
#define HW_PDB_DACINTC1_WR(v)     (HW_PDB_DACINTC1.U = (v))
#define HW_PDB_DACINTC1_SET(v)    (HW_PDB_DACINTC1_WR(HW_PDB_DACINTC1_RD() |  (v)))
#define HW_PDB_DACINTC1_CLR(v)    (HW_PDB_DACINTC1_WR(HW_PDB_DACINTC1_RD() & ~(v)))
#define HW_PDB_DACINTC1_TOG(v)    (HW_PDB_DACINTC1_WR(HW_PDB_DACINTC1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_DACINTC1 bitfields
 */

/*! @name Register PDB_DACINTC1, field TOE[0] (RW)
 *
 * This bit enables the DAC interval trigger.
 *
 * Values:
 * - 0 - DAC interval trigger disabled.
 * - 1 - DAC interval trigger enabled.
 */
//@{
#define BP_PDB_DACINTC1_TOE      (0U)      //!< Bit position for PDB_DACINTC1_TOE.
#define BM_PDB_DACINTC1_TOE      (0x00000001U)  //!< Bit mask for PDB_DACINTC1_TOE.
#define BS_PDB_DACINTC1_TOE      (1U)  //!< Bitfield size in bits for PDB_DACINTC1_TOE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINTC1_TOE field.
#define BR_PDB_DACINTC1_TOE()   (BITBAND_ACCESS32(HW_PDB_DACINTC1_ADDR, BP_PDB_DACINTC1_TOE))
#endif

//! @brief Format value for bitfield PDB_DACINTC1_TOE.
#define BF_PDB_DACINTC1_TOE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINTC1_TOE), uint32_t) & BM_PDB_DACINTC1_TOE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the TOE field to a new value.
#define BW_PDB_DACINTC1_TOE(v)   (BITBAND_ACCESS32(HW_PDB_DACINTC1_ADDR, BP_PDB_DACINTC1_TOE) = (v))
#endif
//@}

/*! @name Register PDB_DACINTC1, field EXT[1] (RW)
 *
 * Enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0 - DAC external trigger input disabled. DAC interval counter is reset and counting starts when a rising
 *     edge is detected on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - DAC external trigger input enabled. DAC interval counter is bypassed and DAC external trigger input
 *     triggers the DAC interval trigger.
 */
//@{
#define BP_PDB_DACINTC1_EXT      (1U)      //!< Bit position for PDB_DACINTC1_EXT.
#define BM_PDB_DACINTC1_EXT      (0x00000002U)  //!< Bit mask for PDB_DACINTC1_EXT.
#define BS_PDB_DACINTC1_EXT      (1U)  //!< Bitfield size in bits for PDB_DACINTC1_EXT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINTC1_EXT field.
#define BR_PDB_DACINTC1_EXT()   (BITBAND_ACCESS32(HW_PDB_DACINTC1_ADDR, BP_PDB_DACINTC1_EXT))
#endif

//! @brief Format value for bitfield PDB_DACINTC1_EXT.
#define BF_PDB_DACINTC1_EXT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINTC1_EXT), uint32_t) & BM_PDB_DACINTC1_EXT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EXT field to a new value.
#define BW_PDB_DACINTC1_EXT(v)   (BITBAND_ACCESS32(HW_PDB_DACINTC1_ADDR, BP_PDB_DACINTC1_EXT) = (v))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_DACINT1 - DAC Interval n register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_DACINT1 - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacint1
{
    uint32_t U;
    struct _hw_pdb_dacint1_bitfields
    {
        uint32_t INT : 16; //!< [15:0] DAC Interval
        uint32_t RESERVED0 : 16; //!< [31:16] 
    } B;
} hw_pdb_dacint1_t;
#endif

/*!
 * @name Constants and macros for entire PDB_DACINT1 register
 */
//@{
#define HW_PDB_DACINT1_ADDR      (REGS_PDB_BASE + 0x15cU)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_DACINT1           (*(__IO hw_pdb_dacint1_t *) HW_PDB_DACINT1_ADDR)
#define HW_PDB_DACINT1_RD()      (HW_PDB_DACINT1.U)
#define HW_PDB_DACINT1_WR(v)     (HW_PDB_DACINT1.U = (v))
#define HW_PDB_DACINT1_SET(v)    (HW_PDB_DACINT1_WR(HW_PDB_DACINT1_RD() |  (v)))
#define HW_PDB_DACINT1_CLR(v)    (HW_PDB_DACINT1_WR(HW_PDB_DACINT1_RD() & ~(v)))
#define HW_PDB_DACINT1_TOG(v)    (HW_PDB_DACINT1_WR(HW_PDB_DACINT1_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_DACINT1 bitfields
 */

/*! @name Register PDB_DACINT1, field INT[15:0] (RW)
 *
 * Specifies the interval value for DAC interval trigger. DAC interval trigger triggers DAC[1:0]
 * update when the DAC interval counter is equal to the DACINT. Reading this field returns the value
 * of internal register that is effective for the current PDB cycle.
 */
//@{
#define BP_PDB_DACINT1_INT      (0U)      //!< Bit position for PDB_DACINT1_INT.
#define BM_PDB_DACINT1_INT      (0x0000ffffU)  //!< Bit mask for PDB_DACINT1_INT.
#define BS_PDB_DACINT1_INT      (16U)  //!< Bitfield size in bits for PDB_DACINT1_INT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_DACINT1_INT field.
#define BR_PDB_DACINT1_INT()   (HW_PDB_DACINT1.B.INT)
#endif

//! @brief Format value for bitfield PDB_DACINT1_INT.
#define BF_PDB_DACINT1_INT(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_DACINT1_INT), uint32_t) & BM_PDB_DACINT1_INT)

#ifndef __LANGUAGE_ASM__
//! @brief Set the INT field to a new value.
#define BW_PDB_DACINT1_INT(v)   (HW_PDB_DACINT1_WR((HW_PDB_DACINT1_RD() & ~BM_PDB_DACINT1_INT) | BF_PDB_DACINT1_INT(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_POEN - Pulse-Out n Enable register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_poen
{
    uint32_t U;
    struct _hw_pdb_poen_bitfields
    {
        uint32_t POEN : 8; //!< [7:0] PDB Pulse-Out Enable
        uint32_t RESERVED0 : 24; //!< [31:8] 
    } B;
} hw_pdb_poen_t;
#endif

/*!
 * @name Constants and macros for entire PDB_POEN register
 */
//@{
#define HW_PDB_POEN_ADDR      (REGS_PDB_BASE + 0x190U)

#ifndef __LANGUAGE_ASM__
#define HW_PDB_POEN           (*(__IO hw_pdb_poen_t *) HW_PDB_POEN_ADDR)
#define HW_PDB_POEN_RD()      (HW_PDB_POEN.U)
#define HW_PDB_POEN_WR(v)     (HW_PDB_POEN.U = (v))
#define HW_PDB_POEN_SET(v)    (HW_PDB_POEN_WR(HW_PDB_POEN_RD() |  (v)))
#define HW_PDB_POEN_CLR(v)    (HW_PDB_POEN_WR(HW_PDB_POEN_RD() & ~(v)))
#define HW_PDB_POEN_TOG(v)    (HW_PDB_POEN_WR(HW_PDB_POEN_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_POEN bitfields
 */

/*! @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB Pulse-Out disabled
 * - 1 - PDB Pulse-Out enabled
 */
//@{
#define BP_PDB_POEN_POEN      (0U)      //!< Bit position for PDB_POEN_POEN.
#define BM_PDB_POEN_POEN      (0x000000ffU)  //!< Bit mask for PDB_POEN_POEN.
#define BS_PDB_POEN_POEN      (8U)  //!< Bitfield size in bits for PDB_POEN_POEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_POEN_POEN field.
#define BR_PDB_POEN_POEN()   (HW_PDB_POEN.B.POEN)
#endif

//! @brief Format value for bitfield PDB_POEN_POEN.
#define BF_PDB_POEN_POEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_POEN_POEN), uint32_t) & BM_PDB_POEN_POEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the POEN field to a new value.
#define BW_PDB_POEN_POEN(v)   (HW_PDB_POEN_WR((HW_PDB_POEN_RD() & ~BM_PDB_POEN_POEN) | BF_PDB_POEN_POEN(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_PDB_POnDLY - Pulse-Out n Delay register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_PDB_POnDLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_pondly
{
    uint32_t U;
    struct _hw_pdb_pondly_bitfields
    {
        uint32_t DLY2 : 16; //!< [15:0] PDB Pulse-Out Delay 2
        uint32_t DLY1 : 16; //!< [31:16] PDB Pulse-Out Delay 1
    } B;
} hw_pdb_pondly_t;
#endif

/*!
 * @name Constants and macros for entire PDB_POnDLY register
 */
//@{
//! @brief Number of instances of the PDB_POnDLY register.
#define HW_PDB_POnDLY_COUNT     (4U)

#define HW_PDB_POnDLY_ADDR(n)   (REGS_PDB_BASE + 0x194U + (0x4U * (n)))

#ifndef __LANGUAGE_ASM__
#define HW_PDB_POnDLY(n)        (*(__IO hw_pdb_pondly_t *) HW_PDB_POnDLY_ADDR(n))
#define HW_PDB_POnDLY_RD(n)     (HW_PDB_POnDLY(n).U)
#define HW_PDB_POnDLY_WR(n, v)  (HW_PDB_POnDLY(n).U = (v))
#define HW_PDB_POnDLY_SET(n, v) (HW_PDB_POnDLY_WR(n, HW_PDB_POnDLY_RD(n) |  (v)))
#define HW_PDB_POnDLY_CLR(n, v) (HW_PDB_POnDLY_WR(n, HW_PDB_POnDLY_RD(n) & ~(v)))
#define HW_PDB_POnDLY_TOG(n, v) (HW_PDB_POnDLY_WR(n, HW_PDB_POnDLY_RD(n) ^  (v)))
#endif
//@}

/*
 * constants & macros for individual PDB_POnDLY bitfields
 */

/*! @name Register PDB_POnDLY, field DLY2[15:0] (RW)
 *
 * These bits specify the delay 2 value for the PDB Pulse-Out. Pulse-Out goes low when the PDB
 * counter is equal to the DLY2. Reading these bits returns the value of internal register that is
 * effective for the current PDB cycle.
 */
//@{
#define BP_PDB_POnDLY_DLY2      (0U)      //!< Bit position for PDB_POnDLY_DLY2.
#define BM_PDB_POnDLY_DLY2      (0x0000ffffU)  //!< Bit mask for PDB_POnDLY_DLY2.
#define BS_PDB_POnDLY_DLY2      (16U)  //!< Bitfield size in bits for PDB_POnDLY_DLY2.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_POnDLY_DLY2 field.
#define BR_PDB_POnDLY_DLY2(n)   (HW_PDB_POnDLY(n).B.DLY2)
#endif

//! @brief Format value for bitfield PDB_POnDLY_DLY2.
#define BF_PDB_POnDLY_DLY2(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_POnDLY_DLY2), uint32_t) & BM_PDB_POnDLY_DLY2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY2 field to a new value.
#define BW_PDB_POnDLY_DLY2(n, v)   (HW_PDB_POnDLY_WR(n, (HW_PDB_POnDLY_RD(n) & ~BM_PDB_POnDLY_DLY2) | BF_PDB_POnDLY_DLY2(v)))
#endif
//@}

/*! @name Register PDB_POnDLY, field DLY1[31:16] (RW)
 *
 * These bits specify the delay 1 value for the PDB Pulse-Out. Pulse-Out goes high when the PDB
 * counter is equal to the DLY1. Reading these bits returns the value of internal register that is
 * effective for the current PDB cycle.
 */
//@{
#define BP_PDB_POnDLY_DLY1      (16U)      //!< Bit position for PDB_POnDLY_DLY1.
#define BM_PDB_POnDLY_DLY1      (0xffff0000U)  //!< Bit mask for PDB_POnDLY_DLY1.
#define BS_PDB_POnDLY_DLY1      (16U)  //!< Bitfield size in bits for PDB_POnDLY_DLY1.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the PDB_POnDLY_DLY1 field.
#define BR_PDB_POnDLY_DLY1(n)   (HW_PDB_POnDLY(n).B.DLY1)
#endif

//! @brief Format value for bitfield PDB_POnDLY_DLY1.
#define BF_PDB_POnDLY_DLY1(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_PDB_POnDLY_DLY1), uint32_t) & BM_PDB_POnDLY_DLY1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DLY1 field to a new value.
#define BW_PDB_POnDLY_DLY1(n, v)   (HW_PDB_POnDLY_WR(n, (HW_PDB_POnDLY_RD(n) & ~BM_PDB_POnDLY_DLY1) | BF_PDB_POnDLY_DLY1(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_pdb_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All PDB module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_pdb
{
    __IO hw_pdb_sc_t SC; //!< [0x0] Status and Control register
    __IO hw_pdb_mod_t MOD; //!< [0x4] Modulus register
    __I hw_pdb_cnt_t CNT; //!< [0x8] Counter register
    __IO hw_pdb_idly_t IDLY; //!< [0xc] Interrupt Delay register
    __IO hw_pdb_ch0c1_t CH0C1; //!< [0x10] Channel n Control register 1
    __IO hw_pdb_ch0s_t CH0S; //!< [0x14] Channel n Status register
    __IO hw_pdb_ch0dly0_t CH0DLY0; //!< [0x18] Channel n Delay 0 register
    __IO hw_pdb_ch0dly1_t CH0DLY1; //!< [0x1c] Channel n Delay 1 register
    uint32_t _reserved0[6];
    __IO hw_pdb_ch1c1_t CH1C1; //!< [0x38] Channel n Control register 1
    __IO hw_pdb_ch1s_t CH1S; //!< [0x3c] Channel n Status register
    __IO hw_pdb_ch1dly0_t CH1DLY0; //!< [0x40] Channel n Delay 0 register
    __IO hw_pdb_ch1dly1_t CH1DLY1; //!< [0x44] Channel n Delay 1 register
    uint32_t _reserved1[6];
    __IO hw_pdb_ch2c1_t CH2C1; //!< [0x60] Channel n Control register 1
    __IO hw_pdb_ch2s_t CH2S; //!< [0x64] Channel n Status register
    __IO hw_pdb_ch2dly0_t CH2DLY0; //!< [0x68] Channel n Delay 0 register
    __IO hw_pdb_ch2dly1_t CH2DLY1; //!< [0x6c] Channel n Delay 1 register
    uint32_t _reserved2[6];
    __IO hw_pdb_ch3c1_t CH3C1; //!< [0x88] Channel n Control register 1
    __IO hw_pdb_ch3s_t CH3S; //!< [0x8c] Channel n Status register
    __IO hw_pdb_ch3dly0_t CH3DLY0; //!< [0x90] Channel n Delay 0 register
    __IO hw_pdb_ch3dly1_t CH3DLY1; //!< [0x94] Channel n Delay 1 register
    uint32_t _reserved3[46];
    __IO hw_pdb_dacintc0_t DACINTC0; //!< [0x150] DAC Interval Trigger n Control register
    __IO hw_pdb_dacint0_t DACINT0; //!< [0x154] DAC Interval n register
    __IO hw_pdb_dacintc1_t DACINTC1; //!< [0x158] DAC Interval Trigger n Control register
    __IO hw_pdb_dacint1_t DACINT1; //!< [0x15c] DAC Interval n register
    uint32_t _reserved4[12];
    __IO hw_pdb_poen_t POEN; //!< [0x190] Pulse-Out n Enable register
    __IO hw_pdb_pondly_t POnDLY[4]; //!< [0x194] Pulse-Out n Delay register
} hw_pdb_t;
#pragma pack()

//! @brief Macro to access all PDB registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_PDB</code>.
#define HW_PDB     (*(hw_pdb_t *) REGS_PDB_BASE)
#endif

#endif // __HW_PDB_REGISTERS_H__
// v22/130417/1.2.6
// EOF
