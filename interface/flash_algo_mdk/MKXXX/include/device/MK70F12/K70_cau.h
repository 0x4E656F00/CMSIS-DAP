/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_CAU_REGISTERS_H__
#define __HW_CAU_REGISTERS_H__

#include "regs.h"

/*
 * K70 CAU
 *
 * Cryptographic Acceleration Unit
 *
 * Registers defined in this header file:
 * - HW_CAU_CASR - Status Register
 * - HW_CAU_CAA - Accumulator
 * - HW_CAU_CAn - General Purpose Register
 *
 * - hw_cau_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_CAU_BASE
#define HW_CAU_INSTANCE_COUNT (1U) //!< Number of instances of the CAU module.
#define REGS_CAU_BASE (0xe0081000U) //!< Base address for CAU.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CAU_CASR - Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CAU_CASR - Status Register (RW)
 *
 * Reset value: 0x20000000U
 *
 * CASR contains the status and configuration for the CAU.
 */
typedef union _hw_cau_casr
{
    uint32_t U;
    struct _hw_cau_casr_bitfields
    {
        uint32_t IC : 1; //!< [0] Illegal Command
        uint32_t DPE : 1; //!< [1] DES Parity Error
        uint32_t RESERVED0 : 26; //!< [27:2] Reserved, must be cleared.
        uint32_t VER : 4; //!< [31:28] CAU Version
    } B;
} hw_cau_casr_t;
#endif

/*!
 * @name Constants and macros for entire CAU_CASR register
 */
//@{
#define HW_CAU_CASR_ADDR      (REGS_CAU_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_CAU_CASR           (*(__IO hw_cau_casr_t *) HW_CAU_CASR_ADDR)
#define HW_CAU_CASR_RD()      (HW_CAU_CASR.U)
#define HW_CAU_CASR_WR(v)     (HW_CAU_CASR.U = (v))
#define HW_CAU_CASR_SET(v)    (HW_CAU_CASR_WR(HW_CAU_CASR_RD() |  (v)))
#define HW_CAU_CASR_CLR(v)    (HW_CAU_CASR_WR(HW_CAU_CASR_RD() & ~(v)))
#define HW_CAU_CASR_TOG(v)    (HW_CAU_CASR_WR(HW_CAU_CASR_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CAU_CASR bitfields
 */

/*! @name Register CAU_CASR, field IC[0] (RW)
 *
 * Indicates an illegal instruction has been executed.
 *
 * Values:
 * - 0 - No illegal commands issued.
 * - 1 - Illegal command issued.
 */
//@{
#define BP_CAU_CASR_IC      (0U)      //!< Bit position for CAU_CASR_IC.
#define BM_CAU_CASR_IC      (0x00000001U)  //!< Bit mask for CAU_CASR_IC.
#define BS_CAU_CASR_IC      (1U)  //!< Bitfield size in bits for CAU_CASR_IC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CAU_CASR_IC field.
#define BR_CAU_CASR_IC()   (BITBAND_ACCESS32(HW_CAU_CASR_ADDR, BP_CAU_CASR_IC))
#endif

//! @brief Format value for bitfield CAU_CASR_IC.
#define BF_CAU_CASR_IC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CAU_CASR_IC), uint32_t) & BM_CAU_CASR_IC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IC field to a new value.
#define BW_CAU_CASR_IC(v)   (BITBAND_ACCESS32(HW_CAU_CASR_ADDR, BP_CAU_CASR_IC) = (v))
#endif
//@}

/*! @name Register CAU_CASR, field DPE[1] (RW)
 *
 * Indicates whether the DES parity error is detected.
 *
 * Values:
 * - 0 - No error detected.
 * - 1 - DES key parity error detected.
 */
//@{
#define BP_CAU_CASR_DPE      (1U)      //!< Bit position for CAU_CASR_DPE.
#define BM_CAU_CASR_DPE      (0x00000002U)  //!< Bit mask for CAU_CASR_DPE.
#define BS_CAU_CASR_DPE      (1U)  //!< Bitfield size in bits for CAU_CASR_DPE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CAU_CASR_DPE field.
#define BR_CAU_CASR_DPE()   (BITBAND_ACCESS32(HW_CAU_CASR_ADDR, BP_CAU_CASR_DPE))
#endif

//! @brief Format value for bitfield CAU_CASR_DPE.
#define BF_CAU_CASR_DPE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CAU_CASR_DPE), uint32_t) & BM_CAU_CASR_DPE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DPE field to a new value.
#define BW_CAU_CASR_DPE(v)   (BITBAND_ACCESS32(HW_CAU_CASR_ADDR, BP_CAU_CASR_DPE) = (v))
#endif
//@}

/*! @name Register CAU_CASR, field VER[31:28] (RO)
 *
 * Indicates CAU version.
 *
 * Values:
 * - 0x1 - Initial CAU version.
 * - 0x2 - Second version, added support for SHA-256 algorithm (This is the value on this device) .
 */
//@{
#define BP_CAU_CASR_VER      (28U)      //!< Bit position for CAU_CASR_VER.
#define BM_CAU_CASR_VER      (0xf0000000U)  //!< Bit mask for CAU_CASR_VER.
#define BS_CAU_CASR_VER      (4U)  //!< Bitfield size in bits for CAU_CASR_VER.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CAU_CASR_VER field.
#define BR_CAU_CASR_VER()   (HW_CAU_CASR.B.VER)
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CAU_CAA - Accumulator
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CAU_CAA - Accumulator (RW)
 *
 * Reset value: 0x00000000U
 *
 * Commands use the CAU accumulator for storage of results and as an operand for the cryptographic
 * algorithms.
 */
typedef union _hw_cau_caa
{
    uint32_t U;
    struct _hw_cau_caa_bitfields
    {
        uint32_t ACC : 32; //!< [31:0] Accumulator
    } B;
} hw_cau_caa_t;
#endif

/*!
 * @name Constants and macros for entire CAU_CAA register
 */
//@{
#define HW_CAU_CAA_ADDR      (REGS_CAU_BASE + 0x1U)

#ifndef __LANGUAGE_ASM__
#define HW_CAU_CAA           (*(__IO hw_cau_caa_t *) HW_CAU_CAA_ADDR)
#define HW_CAU_CAA_RD()      (HW_CAU_CAA.U)
#define HW_CAU_CAA_WR(v)     (HW_CAU_CAA.U = (v))
#define HW_CAU_CAA_SET(v)    (HW_CAU_CAA_WR(HW_CAU_CAA_RD() |  (v)))
#define HW_CAU_CAA_CLR(v)    (HW_CAU_CAA_WR(HW_CAU_CAA_RD() & ~(v)))
#define HW_CAU_CAA_TOG(v)    (HW_CAU_CAA_WR(HW_CAU_CAA_RD() ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CAU_CAA bitfields
 */

/*! @name Register CAU_CAA, field ACC[31:0] (RW)
 *
 * Stores results of various CAU commands.
 */
//@{
#define BP_CAU_CAA_ACC      (0U)      //!< Bit position for CAU_CAA_ACC.
#define BM_CAU_CAA_ACC      (0xffffffffU)  //!< Bit mask for CAU_CAA_ACC.
#define BS_CAU_CAA_ACC      (32U)  //!< Bitfield size in bits for CAU_CAA_ACC.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CAU_CAA_ACC field.
#define BR_CAU_CAA_ACC()   (HW_CAU_CAA.B.ACC)
#endif

//! @brief Format value for bitfield CAU_CAA_ACC.
#define BF_CAU_CAA_ACC(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CAU_CAA_ACC), uint32_t) & BM_CAU_CAA_ACC)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ACC field to a new value.
#define BW_CAU_CAA_ACC(v)   (HW_CAU_CAA_WR((HW_CAU_CAA_RD() & ~BM_CAU_CAA_ACC) | BF_CAU_CAA_ACC(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_CAU_CAn - General Purpose Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CAU_CAn - General Purpose Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The General Purpose Register is used in the CAU commands for storage of results and as operands
 * for various cryptographic algorithms.
 */
typedef union _hw_cau_can
{
    uint32_t U;
    struct _hw_cau_can_bitfields
    {
        uint32_t CAN : 32; //!< [31:0] General Purpose Registers
    } B;
} hw_cau_can_t;
#endif

/*!
 * @name Constants and macros for entire CAU_CAn register
 */
//@{
//! @brief Number of instances of the CAU_CAn register.
#define HW_CAU_CAn_COUNT     (9U)

#define HW_CAU_CAn_ADDR(n)   (REGS_CAU_BASE + 0x2U + (0x4U * (n)))

#ifndef __LANGUAGE_ASM__
#define HW_CAU_CAn(n)        (*(__IO hw_cau_can_t *) HW_CAU_CAn_ADDR(n))
#define HW_CAU_CAn_RD(n)     (HW_CAU_CAn(n).U)
#define HW_CAU_CAn_WR(n, v)  (HW_CAU_CAn(n).U = (v))
#define HW_CAU_CAn_SET(n, v) (HW_CAU_CAn_WR(n, HW_CAU_CAn_RD(n) |  (v)))
#define HW_CAU_CAn_CLR(n, v) (HW_CAU_CAn_WR(n, HW_CAU_CAn_RD(n) & ~(v)))
#define HW_CAU_CAn_TOG(n, v) (HW_CAU_CAn_WR(n, HW_CAU_CAn_RD(n) ^  (v)))
#endif
//@}

/*
 * constants & macros for individual CAU_CAn bitfields
 */

/*! @name Register CAU_CAn, field CAN[31:0] (RW)
 *
 * Used by the CAU commands. Some cryptographic operations work with specific registers.
 */
//@{
#define BP_CAU_CAn_CAN      (0U)      //!< Bit position for CAU_CAn_CAN.
#define BM_CAU_CAn_CAN      (0xffffffffU)  //!< Bit mask for CAU_CAn_CAN.
#define BS_CAU_CAn_CAN      (32U)  //!< Bitfield size in bits for CAU_CAn_CAN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the CAU_CAn_CAN field.
#define BR_CAU_CAn_CAN(n)   (HW_CAU_CAn(n).B.CAN)
#endif

//! @brief Format value for bitfield CAU_CAn_CAN.
#define BF_CAU_CAn_CAN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint32_t) << BP_CAU_CAn_CAN), uint32_t) & BM_CAU_CAn_CAN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CAN field to a new value.
#define BW_CAU_CAn_CAN(n, v)   (HW_CAU_CAn_WR(n, (HW_CAU_CAn_RD(n) & ~BM_CAU_CAn_CAN) | BF_CAU_CAn_CAN(v)))
#endif
//@}

//-------------------------------------------------------------------------------------------
// hw_cau_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All CAU module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_cau
{
    __IO hw_cau_casr_t CASR; //!< [0x0] Status Register
    __IO hw_cau_caa_t CAA; //!< [0x4] Accumulator
    __IO hw_cau_can_t CAn[9]; //!< [0x8] General Purpose Register
} hw_cau_t;
#pragma pack()

//! @brief Macro to access all CAU registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_CAU</code>.
#define HW_CAU     (*(hw_cau_t *) REGS_CAU_BASE)
#endif

#endif // __HW_CAU_REGISTERS_H__
// v22/130417/1.2.6
// EOF
